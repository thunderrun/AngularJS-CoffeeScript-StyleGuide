{
    "docs": [
        {
            "location": "/", 
            "text": "Basics\n\n\nEsLint / CoffeeLint\n\n\nInstall EsLint / CoffeeLint plugin in your Code Editor\n\n\nUse EsLint/CoffeeLint for linting your JavaScript/CoffeeScript.\n\n\n\n\n\n\nProvides a first alert prior to committing any code to source control.\n\n\n\n\n\n\nProvides consistency across your team.\n\n\n\n\n\n\nSingle Responsibility\n\n\nRule of 1\n\n\nDefine 1 component per file, recommended to be less than 400 lines of code\n\n\n\n\n\n\nOne component per file promotes easier unit testing and mocking.\n\n\n\n\n\n\nOne component per file makes it far easier to read, maintain, and avoid collisions with teams in source control.\n\n\n\n\n\n\nOne component per file avoids hidden bugs that often arise when combining components in a file where they may share variables, create unwanted closures, or unwanted coupling with dependencies.\n\n\n\n\n\n\nThe following example defines the \napp\n module and its dependencies, defines a controller, and defines a service all in the same file.\n\n\n# avoid\nangular\n  .module('app', ['ngRoute'])\n  .controller('SomeController' , SomeController)\n  .service('someService' , someService)\n\nSomeController = () -\n\n\nsomeService = () -\n\n\n\n\n\nThe same components are now separated into their own files.\n\n\n# recommended\n\n# app.module.coffee\nangular\n  .module('app', ['ngRoute'])\n\n\n\n\n# recommended\n\n# someController.coffee\n(-\n\n  SomeController = () -\n\n\n  angular\n    .module('app')\n    .controller('SomeController' , SomeController)\n)()\n\n\n\n\n# recommended\n\n# someService.coffee\n(-\n\n  someService = () -\n\n\n  angular\n    .module('app')\n    .service('someService' , someService)\n)()\n\n\n\n\nSmall Functions\n\n\nDefine small functions, no more than 75 LOC (less is better).\n\n\n\n\n\n\nSmall functions are easier to test, especially when they do one thing and serve one purpose.\n\n\n\n\n\n\nSmall functions promote reuse.\n\n\n\n\n\n\nSmall functions are easier to read.\n\n\n\n\n\n\nSmall functions are easier to maintain.\n\n\n\n\n\n\nSmall functions help avoid hidden bugs that come with large functions that share variables with external scope, create unwanted closures, or unwanted coupling with dependencies.\n\n\n\n\n\n\nIIFE\n\n\nJavaScript Scopes\n\n\nWrap Angular components in an Immediately Invoked Function Expression (IIFE).\n\n\n\n\n\n\nAn IIFE removes variables from the global scope. This helps prevent variables and function declarations from living longer than expected in the global scope, which also helps avoid variable collisions.\n\n\n\n\n\n\nWhen your code is minified and bundled into a single file for deployment to a production server, you could have collisions of variables and many global variables. An IIFE protects you against both of these by providing variable scope for each file.\n\n\n\n\n\n\n# avoid\n# loggerService.coffee\nangular\n  .module('app')\n  .service('loggerService', loggerService)\n\n# logger function is added as a global variable\nloggerService = () -\n\n\n# storageService.coffee\nangular\n  .module('app')\n  .service('storageService', storageService)\n\n# storage function is added as a global variable\nstorageService = () -\n\n\n\n\n\n# recommended\n\n# logger.service.coffee\n(-\n\n  loggerService = () -\n\n\n    return\n\n  angular\n  .module('app')\n  .service('loggerService', loggerService)\n)()\n\n# storage.service.coffee\n(-\n\n  storageService = () -\n\n\n    return\n\n  angular\n  .module('app')\n  .service('storageService', storageService)\n)()\n\n\n\n\n\n\n\n\nNote: For brevity only, the rest of the examples in this guide may omit the IIFE syntax.\n\n\n\n\n\n\nNote: IIFE's prevent test code from reaching private members like regular expressions or helper functions which are often good to unit test directly on their own. However you can test these through accessible members or by exposing them through their own component. For example placing helper functions, regular expressions or constants in their own service or constant.\n\n\n\n\n\n\nModules\n\n\nAvoid Naming Collisions\n\n\nUse unique naming conventions with separators for sub-modules\n\n\n\n\nUnique names help avoid module name collisions. Separators help define modules and their submodule hierarchy. For example \napp\n may be your root module while \napp.dashboard\n and \napp.users\n may be modules that are used as dependencies of \napp\n.\n\n\n\n\nDefinitions (aka Setters)\n\n\nDeclare modules without a variable using the setter syntax\n\n\n\n\nWith 1 component per file, there is rarely a need to introduce a variable for the module.\n\n\n\n\n# avoid\n\napp = angular.module('app', [\n  'ngAnimate'\n  'ngRoute'\n  'app.shared'\n  'app.dashboard'\n])\n\n\n\n\nInstead use the simple getter syntax.\n\n\n# recommended\n\nangular\n  .module('app', [\n  'ngAnimate'\n  'ngRoute'\n  'app.shared'\n  'app.dashboard'\n])\n\n\n\n\nGetters\n\n\nWhen using a module, avoid using a variable and instead use chaining with the getter syntax\n\n\n\n\nThis produces more readable code and avoids variable collisions or leaks.\n\n\n\n\n# avoid\napp = angular.module('app')\napp.controller('SomeController' , SomeController)\n\nSomeController = () -\n\n\n\n\n\n# recommended\n(-\n\n  SomeController = () -\n\n\n  return\n\n  angular\n  .module('app')\n  .controller('SomeController' , SomeController)\n)()\n\n\n\n\nSetting vs Getting\n\n\nOnly set once and get for all other instances\n\n\n\n\nA module should only be created once, then retrieved from that point and after.\n\n\n\n\n# recommended\n\n# to set a module\nangular.module('app', [])\n\n# to get a module\nangular.module('app')\n\n\n\n\nNamed vs Anonymous Functions\n\n\nUse named functions instead of passing an anonymous function in as a callback\n\n\n\n\nThis produces more readable code, is much easier to debug, and reduces the amount of nested callback code.\n\n\n\n\n# avoid\nangular\n  .module('app')\n  .controller('Dashboard', () -\n)\n  .service('logger', () -\n)\n\n\n\n\n# recommended\n\n# dashboard.controller.coffee\n(-\n\n  DashboardController = () -\n\n\n    # logic goes here --\n\n\n    return\n\n  angular\n    .module('app')\n    .controller('DashboardController', DashboardController)\n)()\n\n\n\n\n# logger.service.coffee\n\n(-\n\n  loggerService = () -\n\n\n    # logic goes here --\n\n\n    return\n\n  angular\n    .module('app')\n    .service('loggerService', loggerService)\n)()\n\n\n\n\nControllers\n\n\ncontrollerAs View Syntax\n\n\nUse the \ncontrollerAs\n syntax over the \nclassic controller with $scope\n syntax.\n\n\n\n\n\n\nControllers are constructed, \"newed\" up, and provide a single new instance, and the \ncontrollerAs\n syntax is closer to that of a JavaScript constructor than the \nclassic $scope syntax\n.\n\n\n\n\n\n\nIt promotes the use of binding to a \"dotted\" object in the View (e.g. \ncustomer.name\n instead of \nname\n), which is more contextual, easier to read, and avoids any reference issues that may occur without \"dotting\".\n\n\n\n\n\n\nHelps avoid using \n$parent\n calls in Views with nested controllers.\n\n\n\n\n\n\n//- avoid\ndiv(ng-controller=\nCustomerController\n)\n    {{ name }}\n\n\n\n\n//- recommended\ndiv(ng-controller=\nCustomerController as customer\n)\n    {{ customer.name }}\n\n\n\n\ncontrollerAs Controller Syntax\n\n\nUse the \ncontrollerAs\n syntax over the \nclassic controller with $scope\n syntax.\n\n\n\n\n\n\nThe \ncontrollerAs\n syntax uses \nthis\n inside controllers which gets bound to \n$scope\n\n\n\n\n\n\ncontrollerAs\n is syntactic sugar over \n$scope\n. You can still bind to the View and still access \n$scope\n methods.\n\n\n\n\n\n\nHelps avoid the temptation of using \n$scope\n methods inside a controller when it may otherwise be better to avoid them or move the method to a service, and reference them from the controller. Consider using \n$scope\n in a controller only when needed. For example when publishing and subscribing events using \n$emit\n, \n$broadcast\n, or \n$on\n.\n\n\n\n\n\n\n# avoid\n(-\n\n    Customer = () -\n\n      @name = {}\n      @sendMessage = () -\n\n\n          # here @/this is not the same\n          @stuff = \nstuff\n\n\n      return\n\n  angular\n    .module('app')\n    .controller('Customer', Customer)\n)()\n\n\n\n\n# recommended\n(-\n\n    Customer = () -\n\n      vm = @\n      vm.name = {}\n      vm.sendMessage = () -\n\n\n      return\n\n  angular\n    .module('app')\n    .controller('Customer', Customer)\n)()\n\n\n\n\ncontrollerAs with vm\n\n\nUse a capture variable for \nthis\n when using the \ncontrollerAs\n syntax. Choose a consistent variable name such as \nvm\n, which stands for ViewModel.\n\n\n\n\nThe \nthis\n keyword is contextual and when used within a function inside a controller may change its context. Capturing the context of \nthis\n avoids encountering this problem.\n\n\n\n\n# avoid\n(-\n\n    Customer = () -\n\n      @name = {}\n      @sendMessage = () -\n\n\n          # here @/this is not the same\n          @stuff = \nstuff\n\n\n      return\n\n  angular\n    .module('app')\n    .controller('Customer', Customer)\n)()\n\n\n\n\n# recommended\n(-\n\n    Customer = () -\n\n      vm = @\n      vm.name = {}\n      vm.sendMessage = () -\n\n\n      return\n\n  angular\n    .module('app')\n    .controller('Customer', Customer)\n)()\n\n\n\n\nNote: When creating watches in a controller using \ncontroller as\n, you can watch the \nvm.*\n member using the following syntax. (Create watches with caution as they add more load to the digest cycle.)\n\n\ninput(ng-model=\nvm.title\n)\n\n\n\n\nSomeController = ($scope, $log)-\n\n  vm = @\n  vm.title = 'Some Title'\n\n  $scope.$watch 'vm.title', (current, original)-\n\n    $log.info('vm.title was %s', original)\n    $log.info('vm.title is now %s', current)\n\n\n\n\nNote: When working with larger codebases, using a more descriptive name can help ease cognitive overhead \n searchability. Avoid overly verbose names that are cumbersome to type.\n\n\n//- avoid\ninput(ng-model=\ncustomerProductItemVm.title\n)\n\n\n\n\n//- recommended\ninput(ng-model=\nproductVm.title\n)\n\n\n\n\nDefer Controller Logic to Services\n\n\nDefer logic in a controller by delegating to services.\n\n\n\n\n\n\nLogic may be reused by multiple controllers when placed within a service and exposed via a function.\n\n\n\n\n\n\nLogic in a service can more easily be isolated in a unit test, while the calling logic in the controller can be easily mocked.\n\n\n\n\n\n\nRemoves dependencies and hides implementation details from the controller.\n\n\n\n\n\n\nKeeps the controller slim, trim, and focused.\n\n\n\n\n\n\n# avoid\n(-\n\n  Order = ( $http, $q )-\n\n\n    @checkCredit = checkCredit\n    @total = 0\n\n    checkCredit = ()=\n\n        orderTotal = @total\n        $http.get('api/creditcheck').then (data)=\n\n            remaining = data.remaining\n            return $q.when(!!(remaining \n orderTotal))\n  angular\n    .module('app')\n    .controller('Order', Order)\n)()\n\n\n\n\n# recommended\n(-\n\n  OrderController = (creditService)-\n\n\n    vm = @\n\n    init = () -\n\n\n        vm.checkCredit = checkCredit\n        vm.total = 0\n\n    checkCredit = () -\n\n\n        creditService.check()\n\n    init()\n\n    return\n\n  OrderController\n    .$inject = [\n      'creditService'\n    ]\n\n  angular\n    .module('app')\n    .controller('OrderController', OrderController)\n)()\n\n\n\n\nKeep Controllers Focused\n\n\nDefine a controller for a view, and try not to reuse the controller for other views. Instead, move reusable logic to services and keep the controller simple and focused on its view.\n\n\n\n\nReusing controllers with several views is brittle and good end-to-end (e2e) test coverage is required to ensure stability across large applications.\n\n\n\n\nServices\n\n\nSingletons\n\n\nServices are singletons and return an object that contains the members of the service.\n\n\n\n\nServices are instantiated with the \nnew\n keyword, use \nthis\n for public methods and variables. Since these are so similar to factories, use a service instead of factories for consistency.\n\n\n\n\nNote: \nAll Angular services are singletons\n. This means that there is only one instance of a given service per injector.\n\n\n# recommended\n# service\n(-\n\n  loggerService = () -\n\n\n    return {\n        logError: (msg) -\n\n        # ... #\n    }\n\n  angular\n    .module('app')\n    .service('loggerService', loggerService)\n)()\n\n\n\n\nServices Single Responsibility\n\n\nServices should have a \nsingle responsibility\n, that is encapsulated by its context. Once a service begins to exceed that singular purpose, a new service should be created.\n\n\nAccessible Members Up Top\n\n\nExpose the callable members of the service (its interface) at the top, using a technique derived from the \nRevealing Module Pattern\n.\n\n\n\n\n\n\nPlacing the callable members at the top makes it easy to read and helps you instantly identify which members of the service can be called and must be unit tested (and/or mocked).\n\n\n\n\n\n\nThis is especially helpful when the file gets longer as it helps avoid the need to scroll to see what is exposed.\n\n\n\n\n\n\nSetting functions as you go can be easy, but when those functions are more than 1 line of code they can reduce the readability and cause more scrolling. Defining the callable interface via the returned service moves the implementation details down, keeps the callable interface up top, and makes it easier to read.\n\n\n\n\n\n\nNOTE\n: The javascript version of this style guide uses hoisted functions. CoffeeScript does not provide the ability do use function declarations (hoisted functions). So write functions in the return object.\n\n\n# avoid\n(-\n\n  dataService = () -\n\n\n    someValue = ''\n\n    save = () -\n\n        # ... #\n\n    validate = () -\n\n        # ... #\n\n    return\n        save: save,\n        someValue: someValue,\n        validate: validate\n\n  angular\n    .module('app')\n    .service('dataService', dataService)\n)()\n\n\n\n\n# recommended\n(-\n\n  dataService = () -\n\n\n    someValue = ''\n\n    return\n        save: () -\n\n        # . #\n\n        validate: () -\n\n        # . #\n  angular\n    .module('app')\n    .service('dataService', dataService)\n)()\n\n\n\n\nData Services\n\n\nSeparate Data Calls\n\n\nRefactor logic for making data operations and interacting with data to a service. Make data services responsible for XHR calls, local storage, stashing in memory, or any other data operations.\n\n\n\n\n\n\nThe controller's responsibility is for the presentation and gathering of information for the view. It should not care how it gets the data, just that it knows who to ask for it. Separating the data services moves the logic on how to get it to the data service, and lets the controller be simpler and more focused on the view.\n\n\n\n\n\n\nThis makes it easier to test (mock or real) the data calls when testing a controller that uses a data service.\n\n\n\n\n\n\nData service implementation may have very specific code to handle the data repository. This may include headers, how to talk to the data, or other services such as \n$http\n. Separating the logic into a data service encapsulates this logic in a single place hiding the implementation from the outside consumers (perhaps a controller), also making it easier to change the implementation.\n\n\n\n\n\n\n# recommended\n\n# dataService\n(-\n\n  dataService = (\n    $http,\n    logger\n  ) -\n\n\n    getAvengersComplete = (response)-\n\n          response.data.results\n\n    getAvengersFailed = (error)-\n\n          logger.error('XHR Failed for getAvengers.' + error.data)\n\n    return {\n      getAvengers: () -\n\n        return $http.get('/api/maa')\n            .then(getAvengersComplete)\n            .catch(getAvengersFailed)\n    }\n\n\n  dataService\n      .$inject = [\n        '$http',\n        'logger'\n      ]\n\n  angular\n    .module('app.core')\n    .service('dataService', dataService)\n)()\n\n\n\n\nNote: The data service is called from consumers, such as a controller, hiding the implementation from the consumers, as shown below.\n\n\n# recommended\n\n# controller calling the dataservice service\n(-\n\n  AvengersController = (\n    dataService,\n    logger\n  )-\n\n\n    var vm = @\n    vm.avengers = []\n\n    activate = () -\n\n        getAvengers().then () -\n\n            logger.info('Activated Avengers View')\n\n    getAvengers = () -\n\n        dataservice.getAvengers()\n            .then (data)-\n\n                vm.avengers = data\n\n  AvengersController\n    .$inject = [\n      'dataService',\n      'logger'\n    ]\n\n  angular\n    .module('app.avengers')\n    .controller('AvengersController', AvengersController)\n)()\n\n\n\n\nReturn a Promise from Data Calls\n\n\nWhen calling a data service that returns a promise such as \n$http\n, return a promise in your calling function too.\n\n\n\n\nYou can chain the promises together and take further action after the data call completes and resolves or rejects the promise.\n\n\n\n\n# recommended\n\nactivate = () -\n\n\n  # Step 1\n  # Ask the getAvengers function for the avenger data and wait for the promise\n\n  getAvengers().then () -\n\n\n    # Step 4\n    # Perform an action on resolve of final promise\n\n    logger.info('Activated Avengers View')\n\n\ngetAvengers = () -\n\n\n  # Step 2\n  # Ask the data service for the data and wait for the promise\n\n  return dataservice.getAvengers()\n    .then (data)-\n\n\n      # Step 3\n      # set the data and resolve the promise\n\n      vm.avengers = data\n\n\n\n\nManual Annotating for Dependency Injection\n\n\nUnSafe from Minification\n\n\nAvoid using the shortcut syntax of declaring dependencies without using a minification-safe approach.\n\n\n\n\nThe parameters to the component (e.g. controller, service, etc) will be converted to mangled variables. For example, \ncommon\n and \ndataservice\n may become \na\n or \nb\n and not be found by Angular.\n\n\n\n\n# avoid - not minification-safe ###\n(-\n\n  Dashboard = (common, dataservice)-\n\n\n  angular\n    .module('app')\n    .controller('Dashboard', Dashboard)\n)()\n\n\n\n\nThis code may produce mangled variables when minified and thus cause runtime errors.\n\n\n/* avoid - not minification-safe*/\nangular.module('app').controller('DashboardController', d);function d(a, b) { }\n\n\n\n\nManually Identify Dependencies\n\n\nUse \n$inject\n to manually identify your dependencies for Angular components.\n\n\n\n\n\n\nThis technique mirrors the technique used by \nng-annotate\n, which I recommend for automating the creation of minification safe dependencies. If \nng-annotate\n detects injection has already been made, it will not duplicate it.\n\n\n\n\n\n\nThis safeguards your dependencies from being vulnerable to minification issues when parameters may be mangled. For example, \ncommon\n and \ndataservice\n may become \na\n or \nb\n and not be found by Angular.\n\n\n\n\n\n\nAvoid creating in-line dependencies as long lists can be difficult to read in the array. Also it can be confusing that the array is a series of strings while the last item is the component's function.\n\n\n\n\n\n\n# avoid\n(-\n\n  Dashboard = ($location, $routeParams, common, dataservice)-\n\n\n  angular\n    .module('app')\n    .controller('Dashboard',\n        ['$location', '$routeParams', 'common', 'dataservice', Dashboard])\n)()\n\n\n\n\n# recommended\n(-\n\n  Dashboard = (\n    $location,\n    $routeParams,\n    common,\n    dataservice\n  )-\n\n\n    Dashboard\n    .$inject = [\n      '$location',\n      '$routeParams',\n      'common',\n      'dataservice'\n    ]\n\n  angular\n    .module('app')\n    .controller('Dashboard', Dashboard)\n)()\n\n\n\n\nNaming\n\n\nNaming Guidelines\n\n\nUse consistent names for all components following a pattern that describes the component's feature then (optionally) its type. My recommended pattern is \nfeature.type.coffee\n. There are 2 names for most assets:\n\n\n\n\nthe file name (\navengers.controller.coffee\n)\n\n\nthe registered component name with Angular (\nAvengersController\n)\n\n\n\n\n\n\n\n\n\n\nNaming conventions help provide a consistent way to find content at a glance. Consistency within the project is vital. Consistency with a team is important. Consistency across a company provides tremendous efficiency.\n\n\n\n\n\n\nThe naming conventions should simply help you find your code faster and make it easier to understand.\n\n\n\n\n\n\nFeature File Names\n\n\nUse consistent names for all components following a pattern that describes the component's feature then (optionally) its type. My recommended pattern is \nfeature.type.js\n.\n\n\n\n\n\n\nProvides a consistent way to quickly identify components.\n\n\n\n\n\n\nProvides pattern matching for any automated tasks.\n\n\n\n\n\n\n// recommended\n\n// controllers\navengers.controller.coffee\navengers.controller.spec.js\n\n// services/services\nlogger.service.coffee\nlogger.service.spec.js\n\n// constants\nconstants.coffee\n\n// module definition\navengers.module.coffee\n\n// routes\navengers.routes.coffee\navengers.routes.spec.js\n\n// configuration\navengers.config.coffee\n\n// directives\navenger-profile.directive.coffee\navenger-profile.directive.spec.js\n\n\n\n\nTest File Names\n\n\nName test specifications similar to the component they test with a suffix of \nspec\n.\n\n\n\n\n\n\nProvides a consistent way to quickly identify components.\n\n\n\n\n\n\nProvides pattern matching for \nkarma\n or other test runners.\n\n\n\n\n\n\n// recommended\n\navengers.controller.spec.js\nlogger.service.spec.js\navengers.routes.spec.js\navenger-profile.directive.spec.js\n\n\n\n\nController Names\n\n\nUse consistent names for all controllers named after their feature. Use UpperCamelCase for controllers, as they are constructors.\n\n\n\n\n\n\nProvides a consistent way to quickly identify and reference controllers.\n\n\n\n\n\n\nUpperCamelCase is conventional for identifying object that can be instantiated using a constructor.\n\n\n\n\n\n\n# recommended\n\n#avengers.controller.coffee\n(-\n\n  HeroAvengersController = ()-\n\n\n  angular\n    .module\n    .controller('HeroAvengersController', HeroAvengersController)\n)()\n\n\n\n\nController Name Suffix\n\n\nAppend the controller name with the suffix \nController\n.\n\n\n\n\nThe \nController\n suffix is more commonly used and is more explicitly descriptive.\n\n\n\n\n# recommended\n\n# avengers.controller.coffee\n(-\n\n  AvengersController = () -\n\n\n    return\n\n  angular\n    .module\n    .controller('AvengersController', AvengersController)\n)()\n\n\n\n\nService Names\n\n\nUse consistent names for all services named after their feature. Use camel-casing for services. Avoid prefixing services with \n$\n. Always suffix services with \nService\n.\n\n\n\n\n\n\nProvides a consistent way to quickly identify and reference services.\n\n\n\n\n\n\nAvoids name collisions with built-in services that use the \n$\n prefix.\n\n\n\n\n\n\nClear service names such as \nlogger\n do not require a suffix.\n\n\n\n\n\n\nService names such as \navengers\n are nouns and require a suffix and should be named \navengersService\n.\n\n\n\n\n\n\n# recommended\n\n# logger.service.coffee\n(-\n\n  loggerService = () -\n\n\n  angular\n    .module\n    .service('loggerService', loggerService)\n)()\n\n# credit.service.coffee\n(-\n\n  creditService = () -\n\n\n  angular\n  .module\n  .service('creditService', creditService)\n)()\n\n# customer.service.coffee\n(-\n\n  customerService = () -\n\n\n  angular\n    .module\n    .service('customerService', customerService)\n)()\n\n\n\n\nDirective Component Names\n\n\nUse consistent names for all directives using camel-case. Use a short prefix to describe the area that the directives belong (some example are company prefix or project prefix).\n\n\n\n\nProvides a consistent way to quickly identify and reference components.\n\n\n\n\n# recommended\n\n# avenger-profile.directive.coffee\n(-\n\n  xxAvengerProfile = () -\n\n    return\n\n  angular\n    .module\n    .directive('xxAvengerProfile', xxAvengerProfile)\n)()\n\n# usage is \nxx-avenger-profile\n \n/xx-avenger-profile\n\n\n\n\n\nModules Names\n\n\nWhen there are multiple modules, the main module file is named \napp.module.coffee\n while other dependent modules are named after what they represent. For example, an admin module is named \nadmin.module.coffee\n. The respective registered module names would be \napp\n and \nadmin\n.\n\n\n\n\n\n\nProvides consistency for multiple module apps, and for expanding to large applications.\n\n\n\n\n\n\nProvides easy way to use task automation to load all module definitions first, then all other angular files (for bundling).\n\n\n\n\n\n\nConfiguration\n\n\nSeparate configuration for a module into its own file named after the module. A configuration file for the main \napp\n module is named \napp.config.coffee\n (or simply \nconfig.coffee\n). A configuration for a module named \nadmin.module.coffee\n is named \nadmin.config.coffee\n.\n\n\n\n\n\n\nSeparates configuration from module definition, components, and active code.\n\n\n\n\n\n\nProvides an identifiable place to set configuration for a module.\n\n\n\n\n\n\nRoutes\n\n\neparate route configuration into its own file. Examples might be \napp.route.coffee\n for the main module and \nadmin.route.coffee\n for the \nadmin\n module. Even in smaller apps I prefer this separation from the rest of the configuration.\n\n\nApplication Structure LIFT Principle\n\n\nLIFT\n\n\nStructure your app such that you can \nL\nocate your code quickly, \nI\ndentify the code at a glance, keep the \nF\nlattest structure you can, and \nT\nry to stay DRY. The structure should follow these 4 basic guidelines.\n\n\n\n\nProvides a consistent structure that scales well, is modular, and makes it easier to increase developer efficiency by finding code quickly. Another way to check your app structure is to ask yourself: How quickly can you open and work in all of the related files for a feature?\n\n\n\n\nWhen I find my structure is not feeling comfortable, I go back and revisit these LIFT guidelines\n\n\n\n\nL\nocating our code is easy\n\n\nI\ndentify code at a glance\n\n\nF\nlat structure as long as we can\n\n\nT\nry to stay DRY (Don\u2019t Repeat Yourself) or T-DRY\n\n\n\n\nLocate\n\n\nMake locating your code intuitive, simple and fast.\n\n\n\n\nI find this to be super important for a project. If the team cannot find the files they need to work on quickly, they will not be able to work as efficiently as possible, and the structure needs to change. You may not know the file name or where its related files are, so putting them in the most intuitive locations and near each other saves a ton of time. A descriptive folder structure can help with this.\n\n\n\n\n/bower_components\n/client\n  /app\n    /avengers\n    /blocks\n      /exception\n      /logger\n    /core\n    /dashboard\n    /data\n    /layout\n    /widgets\n  /content\n  index.pug\n.bower.json\n\n\n\n\nIdentify\n\n\nWhen you look at a file you should instantly know what it contains and represents.\n\n\n\n\nYou spend less time hunting and pecking for code, and become more efficient. If this means you want longer file names, then so be it. Be descriptive with file names and keeping the contents of the file to exactly 1 component. Avoid files with multiple controllers, multiple services, or a mixture. There are deviations of the 1 per file rule when I have a set of very small features that are all related to each other, they are still easily identifiable.\n\n\n\n\nFlat\n\n\nKeep a flat folder structure as long as possible. When you get to 7+ files, begin considering separation.\n\n\n\n\nNobody wants to search 7 levels of folders to find a file. Think about menus on web sites \u2026 anything deeper than 2 should take serious consideration. In a folder structure there is no hard and fast number rule, but when a folder has 7-10 files, that may be time to create subfolders. Base it on your comfort level. Use a flatter structure until there is an obvious value (to help the rest of LIFT) in creating a new folder.\n\n\n\n\nT-DRY (Try to Stick to DRY)\n\n\nBe DRY, but don't go nuts and sacrifice readability.\n\n\n\n\nBeing DRY is important, but not crucial if it sacrifices the others in LIFT, which is why I call it T-DRY. I don\u2019t want to type session-view.html for a view because, well, it\u2019s obviously a view. If it is not obvious or by convention, then I name it.\n\n\n\n\nApplication Structure\n\n\nOverall Guidelines\n\n\nHave a near term view of implementation and a long term vision. In other words, start small but keep in mind on where the app is heading down the road. All of the app's code goes in a root folder named \napp\n. All content is 1 feature per file. Each controller, service, module, view is in its own file. All 3rd party vendor scripts are stored in another root folder and not in the \napp\n folder. I didn't write them and I don't want them cluttering my app (\nbower_components\n, \nscripts\n, \nlib\n).\n\n\nNote: Find more details and reasoning behind the structure at \nthis original post on application structure\n.\n\n\nLayout\n\n\nPlace components that define the overall layout of the application in a folder named \nlayout\n. These may include a shell view and controller may act as the container for the app, navigation, menus, content areas, and other regions.\n\n\n\n\nOrganizes all layout in a single place re-used throughout the application.\n\n\n\n\nFolders-by-Feature Structure\n\n\nCreate folders named for the feature they represent. When a folder grows to contain more than 7 files, start to consider creating a folder for them. Your threshold may be different, so adjust as needed.\n\n\n\n\n\n\nA developer can locate the code, identify what each file represents at a glance, the structure is flat as can be, and there is no repetitive nor redundant names.\n\n\n\n\n\n\nThe LIFT guidelines are all covered.\n\n\n\n\n\n\nHelps reduce the app from becoming cluttered through organizing the content and keeping them aligned with the LIFT guidelines.\n\n\n\n\n\n\nWhen there are a lot of files (10+) locating them is easier with a consistent folder structures and more difficult in flat structures.\n\n\n\n\n\n\n/**\n* recommended\n*/\n\napp/\n    app.module.coffee\n    app.config.coffee\n    components/\n        calendar.directive.coffee\n        calendar.directive.pug\n        user-profile.directive.coffee\n        user-profile.directive.pug\n    layout/\n        shell.pug\n        shell.controller.coffee\n        topnav.pug\n        topnav.controller.coffee\n    people/\n        attendees/\n            attendees.pug\n            attendees.controller.coffee\n            attendees.service.coffee\n        speekers/\n            speaker-detail/\n                speaker-detail.pug\n                speaker-detail.controller.coffee\n                speaker-detail.service.coffee\n            speakers.pug\n            speakers.controller.coffee\n        people.routes.coffee\n    services/\n        localstorage.service.coffee\n        logger.service.coffee\n        spinner.service.coffee\n    sessions/\n        session-detial/\n            session-detail.pug\n            session-detail.controller.coffee\n            session-detail.service.coffee\n        sessions.pug\n        sessions.controller.coffee\n        sessions.routes.coffee\n        sessions.service.coffee\n\n\n\n\nNote: Do not structure your app using folders-by-type. This requires moving to multiple folders when working on a feature and gets unwieldy quickly as the app grows to 5, 10 or 25+ views and controllers (and other features), which makes it more difficult than folder-by-feature to locate files.\n\n\n/*\n* avoid\n* Alternative folders-by-type.\n* I recommend \nfolders-by-feature\n, instead.\n*/\n\napp/\n    app.module.coffee\n    app.config.coffee\n    app.routes.coffee\n    directives.coffee\n    controllers/\n        attendees.coffee\n        session-detail.coffee\n        sessions.coffee\n        shell.coffee\n        speakers.coffee\n        speaker-detail.coffee\n        topnav.coffee\n    directives/\n        calendar.directive.coffee\n        calendar.directive.pug\n        user-profile.directive.coffee\n        user-profile.directive.pug\n    services/\n        dataservice.coffee\n        localstorage.coffee\n        logger.coffee\n        spinner.coffee\n    views/\n        attendees.pug\n        session-detail.pug\n        sessions.pug\n        shell.pug\n        speakers.pug\n        speaker-detail.pug\n        topnav.pug\n\n\n\n\nModularity\n\n\nMany Small, Self Contained Modules\n\n\nCreate small modules that encapsulate one responsibility.\n\n\n\n\nModular applications make it easy to plug and go as they allow the development teams to build vertical slices of the applications and roll out incrementally. This means we can plug in new features as we develop them.\n\n\n\n\nCreate an App Module\n\n\nCreate an application root module whose role is to pull together all of the modules and features of your application. Name this for your application.\n\n\n\n\nAngular encourages modularity and separation patterns. Creating an application root module whose role is to tie your other modules together provides a very straightforward way to add or remove modules from your application.\n\n\n\n\nKeep the App Module Thin\n\n\nOnly put logic for pulling together the app in the application module. Leave features in their own modules.\n\n\n\n\n\n\nAdding additional roles to the application root to get remote data, display views, or other logic not related to pulling the app together muddies the app module and make both sets of features harder to reuse or turn off.\n\n\n\n\n\n\nThe app module becomes a manifest that describes which modules help define the application.\n\n\n\n\n\n\nFeature Areas are Modules\n\n\nCreate modules that represent feature areas, such as layout, reusable and shared services, dashboards, and app specific features (e.g. customers, admin, sales).\n\n\n\n\n\n\nSelf contained modules can be added to the application with little or no friction.\n\n\n\n\n\n\nSprints or iterations can focus on feature areas and turn them on at the end of the sprint or iteration.\n\n\n\n\n\n\nSeparating feature areas into modules makes it easier to test the modules in isolation and reuse code.\n\n\n\n\n\n\nReusable Blocks are Modules\n\n\nCreate modules that represent reusable application blocks for common services such as exception handling, logging, diagnostics, security, and local data stashing.\n\n\n\n\nThese types of features are needed in many applications, so by keeping them separated in their own modules they can be application generic and be reused across applications.\n\n\n\n\nModule Dependencies\n\n\nThe application root module depends on the app specific feature modules and any shared or reusable modules.\n\n\n\n\n\n\n\n\nThe main app module contains a quickly identifiable manifest of the application's features.\n\n\n\n\n\n\nEach feature area contains a manifest of what it depends on, so it can be pulled in as a dependency in other applications and still work.\n\n\n\n\n\n\nIntra-App features such as shared data services become easy to locate and share from within \napp.core\n (choose your favorite name for this module).\n\n\n\n\n\n\nNote: This is a strategy for consistency. There are many good options here. Choose one that is consistent, follows Angular's dependency rules, and is easy to maintain and scale.\n\n\n\n\nMy structures vary slightly between projects but they all follow these guidelines for structure and modularity. The implementation may vary depending on the features and the team. In other words, don't get hung up on an exact like-for-like structure but do justify your structure using consistency, maintainability, and efficiency in mind.\n\n\nIn a small app, you can also consider putting all the shared dependencies in the app module where the feature modules have no direct dependencies. This makes it easier to maintain the smaller application, but makes it harder to reuse modules outside of this application.\n\n\n\n\nTesting\n\n\nUnit testing helps maintain clean code, as such I included some of my recommendations for unit testing foundations with links for more information.\n\n\nWrite Tests with Stories\n\n\nWrite a set of tests for every story. Start with an empty test and fill them in as you write the code for the story.\n\n\n\n\nWriting the test descriptions helps clearly define what your story will do, will not do, and how you can measure success.\n\n\n\n\nit('should have Avengers controller', function() {\n    // TODO\n});\n\nit('should find 1 Avenger when filtered by name', function() {\n    // TODO\n});\n\nit('should have 10 Avengers', function() {\n    // TODO (mock data?)\n});\n\nit('should return Avengers via XHR', function() {\n    // TODO ($httpBackend?)\n});\n\n// and so on\n\n\n\n\nTesting Library\n\n\nUse \nJasmine\n or \nMocha\n for unit testing.\n\n\n\n\n\n\nBoth Jasmine and Mocha are widely used in the Angular community. Both are stable, well maintained, and provide robust testing features.\n\n\nNote: When using Mocha, also consider choosing an assert library such as \nChai\n. I prefer Mocha.\n\n\n\n\n\n\nTest Runner\n\n\nUse \nKarma\n as a test runner.\n\n\n\n\n\n\nKarma is easy to configure to run once or automatically when you change your code.\n\n\n\n\n\n\nKarma hooks into your Continuous Integration process easily on its own or through Grunt or Gulp.\n\n\n\n\n\n\nSome IDE's are beginning to integrate with Karma, such as \nWebStorm\n and \nVisual Studio\n.\n\n\n\n\n\n\nKarma works well with task automation leaders such as \nGrunt\n (with \ngrunt-karma\n) and \nGulp\n. When using Gulp, use \nKarma\n directly and not with a plugin as the API can be called directly.\n\n\n\n\n\n\n/* recommended */\n\n// Gulp example with Karma directly\nfunction startTests(singleRun, done) {\n    var child;\n    var excludeFiles = [];\n    var fork = require('child_process').fork;\n    var Server = require('karma').Server;\n    var serverSpecs = config.serverIntegrationSpecs;\n\n    if (args.startServers) {\n        log('Starting servers');\n        var savedEnv = process.env;\n        savedEnv.NODE_ENV = 'dev';\n        savedEnv.PORT = 8888;\n        child = fork(config.nodeServer);\n    } else {\n        if (serverSpecs \n serverSpecs.length) {\n            excludeFiles = serverSpecs;\n        }\n    }\n\n    var karmaOptions = {\n      configFile: __dirname + '/karma.conf.js',\n      exclude: excludeFiles,\n      singleRun: !!singleRun\n    };\n\n    let server = new Server(karmaOptions, karmaCompleted);\n    server.start();\n\n    ////////////////\n\n    function karmaCompleted(karmaResult) {\n        log('Karma completed');\n        if (child) {\n            log('shutting down the child process');\n            child.kill();\n        }\n        if (karmaResult === 1) {\n            done('karma: tests failed with code ' + karmaResult);\n        } else {\n            done();\n        }\n    }\n}\n\n\n\n\nStubbing and Spying\n\n\nUse \nSinon\n for stubbing and spying.\n\n\n\n\n\n\nSinon works well with both Jasmine and Mocha and extends the stubbing and spying features they offer.\n\n\n\n\n\n\nSinon makes it easier to toggle between Jasmine and Mocha, if you want to try both.\n\n\n\n\n\n\nSinon has descriptive messages when tests fail the assertions.\n\n\n\n\n\n\nHeadless Browser\n\n\nUse \nPhantomJS\n to run your tests on a server.\n\n\n\n\nPhantomJS is a headless browser that helps run your tests without needing a \"visual\" browser. So you do not have to install Chrome, Safari, IE, or other browsers on your server.\n\n\n\n\nNote: You should still test on all browsers in your environment, as appropriate for your target audience.\n\n\nOrganizing Tests\n\n\nPlace unit test files (specs) side-by-side with your client code. Place specs that cover server integration or test multiple components in a separate \ntests\n folder.\n\n\n\n\n\n\nUnit tests have a direct correlation to a specific component and file in source code.\n\n\n\n\n\n\nIt is easier to keep them up to date since they are always in sight. When coding whether you do TDD or test during development or test after development, the specs are side-by-side and never out of sight nor mind, and thus more likely to be maintained which also helps maintain code coverage.\n\n\n\n\n\n\nWhen you update source code it is easier to go update the tests at the same time.\n\n\n\n\n\n\nPlacing them side-by-side makes it easy to find them and easy to move them with the source code if you move the source.\n\n\n\n\n\n\nHaving the spec nearby makes it easier for the source code reader to learn how the component is supposed to be used and to discover its known limitations.\n\n\n\n\n\n\nSeparating specs so they are not in a distributed build is easy with grunt or gulp.\n\n\n\n\n\n\n// recommended\n\nsrc/client/app/customers/customer-detail.controller.coffee\n                        /customer-detail.controller.spec.js\n                        /customers.controller.coffee\n                        /customers.controller.spec.js\n                        /customers.module.coffee\n                        /customers.route.coffee\n                        /customers.route.spec.js\n\n\n\n\nConstants\n\n\nVendor Globals\n\n\nCreate an Angular Constant for vendor libraries' global variables.\n\n\n\n\nProvides a way to inject vendor libraries that otherwise are globals. This improves code testability by allowing you to more easily know what the dependencies of your components are (avoids leaky abstractions). It also allows you to mock these dependencies, where it makes sense.\n\n\n\n\n# constants.coffee\n\n# global toastr:false, moment:false\n\nangular\n  .module('app.core')\n    .constant('toastr', toastr)\n    .constant('moment', moment)\n\n\n\n\nUse constants for values that do not change and do not come from another service. When constants are used only for a module that may be reused in multiple applications, place constants in a file per module named after the module. Until this is required, keep constants in the main module in a \nconstants.js\n file.\n\n\n\n\n\n\nA value that may change, even infrequently, should be retrieved from a service so you do not have to change the source code. For example, a url for a data service could be placed in a constants but a better place would be to load it from a web service.\n\n\n\n\n\n\nConstants can be injected into any angular component, including providers.\n\n\n\n\n\n\nWhen an application is separated into modules that may be reused in other applications, each stand-alone module should be able to operate on its own including any dependent constants.\n\n\n\n\n\n\n# Constants used by the entire app\nangular\n  .module('app.core')\n  .constant('moment', moment);\n\n# Constants used only by the sales module\nangular\n  .module('app.sales')\n  .constant('events', {\n    ORDER_CREATED: 'event_order_created',\n    INVENTORY_DEPLETED: 'event_inventory_depleted'\n  })\n\n\n\n\nUse task automation to list module definition files \n*.module.coffee\n before all other application JavaScript files.\n\n\n\n\n\n\nAngular needs the module definitions to be registered before they are used.\n\n\n\n\n\n\nNaming modules with a specific pattern such as \n*.module.coffee\n makes it easy to grab them with a glob and list them first.\n\n\n\n\n\n\nvar clientApp = './src/client/app/';\n\n// Always grab module files first\nvar files = [\n  clientApp + '**/*.module.coffee',\n  clientApp + '**/*.coffee'\n];\n\n\n\n\nAngular Docs\n\n\nFor anything else, API reference, check the \nAngular documentation\n and follow its code style if not mentioned in this guide.", 
            "title": "Basics"
        }, 
        {
            "location": "/#basics", 
            "text": "", 
            "title": "Basics"
        }, 
        {
            "location": "/#eslint-coffeelint", 
            "text": "", 
            "title": "EsLint / CoffeeLint"
        }, 
        {
            "location": "/#install-eslint-coffeelint-plugin-in-your-code-editor", 
            "text": "Use EsLint/CoffeeLint for linting your JavaScript/CoffeeScript.    Provides a first alert prior to committing any code to source control.    Provides consistency across your team.", 
            "title": "Install EsLint / CoffeeLint plugin in your Code Editor"
        }, 
        {
            "location": "/#single-responsibility", 
            "text": "", 
            "title": "Single Responsibility"
        }, 
        {
            "location": "/#rule-of-1", 
            "text": "Define 1 component per file, recommended to be less than 400 lines of code    One component per file promotes easier unit testing and mocking.    One component per file makes it far easier to read, maintain, and avoid collisions with teams in source control.    One component per file avoids hidden bugs that often arise when combining components in a file where they may share variables, create unwanted closures, or unwanted coupling with dependencies.    The following example defines the  app  module and its dependencies, defines a controller, and defines a service all in the same file.  # avoid\nangular\n  .module('app', ['ngRoute'])\n  .controller('SomeController' , SomeController)\n  .service('someService' , someService)\n\nSomeController = () - \n\nsomeService = () -   The same components are now separated into their own files.  # recommended\n\n# app.module.coffee\nangular\n  .module('app', ['ngRoute'])  # recommended\n\n# someController.coffee\n(- \n  SomeController = () - \n\n  angular\n    .module('app')\n    .controller('SomeController' , SomeController)\n)()  # recommended\n\n# someService.coffee\n(- \n  someService = () - \n\n  angular\n    .module('app')\n    .service('someService' , someService)\n)()", 
            "title": "Rule of 1"
        }, 
        {
            "location": "/#small-functions", 
            "text": "Define small functions, no more than 75 LOC (less is better).    Small functions are easier to test, especially when they do one thing and serve one purpose.    Small functions promote reuse.    Small functions are easier to read.    Small functions are easier to maintain.    Small functions help avoid hidden bugs that come with large functions that share variables with external scope, create unwanted closures, or unwanted coupling with dependencies.", 
            "title": "Small Functions"
        }, 
        {
            "location": "/#iife", 
            "text": "", 
            "title": "IIFE"
        }, 
        {
            "location": "/#javascript-scopes", 
            "text": "Wrap Angular components in an Immediately Invoked Function Expression (IIFE).    An IIFE removes variables from the global scope. This helps prevent variables and function declarations from living longer than expected in the global scope, which also helps avoid variable collisions.    When your code is minified and bundled into a single file for deployment to a production server, you could have collisions of variables and many global variables. An IIFE protects you against both of these by providing variable scope for each file.    # avoid\n# loggerService.coffee\nangular\n  .module('app')\n  .service('loggerService', loggerService)\n\n# logger function is added as a global variable\nloggerService = () - \n\n# storageService.coffee\nangular\n  .module('app')\n  .service('storageService', storageService)\n\n# storage function is added as a global variable\nstorageService = () -   # recommended\n\n# logger.service.coffee\n(- \n  loggerService = () - \n\n    return\n\n  angular\n  .module('app')\n  .service('loggerService', loggerService)\n)()\n\n# storage.service.coffee\n(- \n  storageService = () - \n\n    return\n\n  angular\n  .module('app')\n  .service('storageService', storageService)\n)()    Note: For brevity only, the rest of the examples in this guide may omit the IIFE syntax.    Note: IIFE's prevent test code from reaching private members like regular expressions or helper functions which are often good to unit test directly on their own. However you can test these through accessible members or by exposing them through their own component. For example placing helper functions, regular expressions or constants in their own service or constant.", 
            "title": "JavaScript Scopes"
        }, 
        {
            "location": "/#modules", 
            "text": "", 
            "title": "Modules"
        }, 
        {
            "location": "/#avoid-naming-collisions", 
            "text": "Use unique naming conventions with separators for sub-modules   Unique names help avoid module name collisions. Separators help define modules and their submodule hierarchy. For example  app  may be your root module while  app.dashboard  and  app.users  may be modules that are used as dependencies of  app .", 
            "title": "Avoid Naming Collisions"
        }, 
        {
            "location": "/#definitions-aka-setters", 
            "text": "Declare modules without a variable using the setter syntax   With 1 component per file, there is rarely a need to introduce a variable for the module.   # avoid\n\napp = angular.module('app', [\n  'ngAnimate'\n  'ngRoute'\n  'app.shared'\n  'app.dashboard'\n])  Instead use the simple getter syntax.  # recommended\n\nangular\n  .module('app', [\n  'ngAnimate'\n  'ngRoute'\n  'app.shared'\n  'app.dashboard'\n])", 
            "title": "Definitions (aka Setters)"
        }, 
        {
            "location": "/#getters", 
            "text": "When using a module, avoid using a variable and instead use chaining with the getter syntax   This produces more readable code and avoids variable collisions or leaks.   # avoid\napp = angular.module('app')\napp.controller('SomeController' , SomeController)\n\nSomeController = () -   # recommended\n(- \n  SomeController = () - \n\n  return\n\n  angular\n  .module('app')\n  .controller('SomeController' , SomeController)\n)()", 
            "title": "Getters"
        }, 
        {
            "location": "/#setting-vs-getting", 
            "text": "Only set once and get for all other instances   A module should only be created once, then retrieved from that point and after.   # recommended\n\n# to set a module\nangular.module('app', [])\n\n# to get a module\nangular.module('app')", 
            "title": "Setting vs Getting"
        }, 
        {
            "location": "/#named-vs-anonymous-functions", 
            "text": "Use named functions instead of passing an anonymous function in as a callback   This produces more readable code, is much easier to debug, and reduces the amount of nested callback code.   # avoid\nangular\n  .module('app')\n  .controller('Dashboard', () - )\n  .service('logger', () - )  # recommended\n\n# dashboard.controller.coffee\n(- \n  DashboardController = () - \n\n    # logic goes here -- \n\n    return\n\n  angular\n    .module('app')\n    .controller('DashboardController', DashboardController)\n)()  # logger.service.coffee\n\n(- \n  loggerService = () - \n\n    # logic goes here -- \n\n    return\n\n  angular\n    .module('app')\n    .service('loggerService', loggerService)\n)()", 
            "title": "Named vs Anonymous Functions"
        }, 
        {
            "location": "/#controllers", 
            "text": "", 
            "title": "Controllers"
        }, 
        {
            "location": "/#controlleras-view-syntax", 
            "text": "Use the  controllerAs  syntax over the  classic controller with $scope  syntax.    Controllers are constructed, \"newed\" up, and provide a single new instance, and the  controllerAs  syntax is closer to that of a JavaScript constructor than the  classic $scope syntax .    It promotes the use of binding to a \"dotted\" object in the View (e.g.  customer.name  instead of  name ), which is more contextual, easier to read, and avoids any reference issues that may occur without \"dotting\".    Helps avoid using  $parent  calls in Views with nested controllers.    //- avoid\ndiv(ng-controller= CustomerController )\n    {{ name }}  //- recommended\ndiv(ng-controller= CustomerController as customer )\n    {{ customer.name }}", 
            "title": "controllerAs View Syntax"
        }, 
        {
            "location": "/#controlleras-controller-syntax", 
            "text": "Use the  controllerAs  syntax over the  classic controller with $scope  syntax.    The  controllerAs  syntax uses  this  inside controllers which gets bound to  $scope    controllerAs  is syntactic sugar over  $scope . You can still bind to the View and still access  $scope  methods.    Helps avoid the temptation of using  $scope  methods inside a controller when it may otherwise be better to avoid them or move the method to a service, and reference them from the controller. Consider using  $scope  in a controller only when needed. For example when publishing and subscribing events using  $emit ,  $broadcast , or  $on .    # avoid\n(- \n    Customer = () - \n      @name = {}\n      @sendMessage = () - \n\n          # here @/this is not the same\n          @stuff =  stuff \n\n      return\n\n  angular\n    .module('app')\n    .controller('Customer', Customer)\n)()  # recommended\n(- \n    Customer = () - \n      vm = @\n      vm.name = {}\n      vm.sendMessage = () - \n\n      return\n\n  angular\n    .module('app')\n    .controller('Customer', Customer)\n)()", 
            "title": "controllerAs Controller Syntax"
        }, 
        {
            "location": "/#controlleras-with-vm", 
            "text": "Use a capture variable for  this  when using the  controllerAs  syntax. Choose a consistent variable name such as  vm , which stands for ViewModel.   The  this  keyword is contextual and when used within a function inside a controller may change its context. Capturing the context of  this  avoids encountering this problem.   # avoid\n(- \n    Customer = () - \n      @name = {}\n      @sendMessage = () - \n\n          # here @/this is not the same\n          @stuff =  stuff \n\n      return\n\n  angular\n    .module('app')\n    .controller('Customer', Customer)\n)()  # recommended\n(- \n    Customer = () - \n      vm = @\n      vm.name = {}\n      vm.sendMessage = () - \n\n      return\n\n  angular\n    .module('app')\n    .controller('Customer', Customer)\n)()  Note: When creating watches in a controller using  controller as , you can watch the  vm.*  member using the following syntax. (Create watches with caution as they add more load to the digest cycle.)  input(ng-model= vm.title )  SomeController = ($scope, $log)- \n  vm = @\n  vm.title = 'Some Title'\n\n  $scope.$watch 'vm.title', (current, original)- \n    $log.info('vm.title was %s', original)\n    $log.info('vm.title is now %s', current)  Note: When working with larger codebases, using a more descriptive name can help ease cognitive overhead   searchability. Avoid overly verbose names that are cumbersome to type.  //- avoid\ninput(ng-model= customerProductItemVm.title )  //- recommended\ninput(ng-model= productVm.title )", 
            "title": "controllerAs with vm"
        }, 
        {
            "location": "/#defer-controller-logic-to-services", 
            "text": "Defer logic in a controller by delegating to services.    Logic may be reused by multiple controllers when placed within a service and exposed via a function.    Logic in a service can more easily be isolated in a unit test, while the calling logic in the controller can be easily mocked.    Removes dependencies and hides implementation details from the controller.    Keeps the controller slim, trim, and focused.    # avoid\n(- \n  Order = ( $http, $q )- \n\n    @checkCredit = checkCredit\n    @total = 0\n\n    checkCredit = ()= \n        orderTotal = @total\n        $http.get('api/creditcheck').then (data)= \n            remaining = data.remaining\n            return $q.when(!!(remaining   orderTotal))\n  angular\n    .module('app')\n    .controller('Order', Order)\n)()  # recommended\n(- \n  OrderController = (creditService)- \n\n    vm = @\n\n    init = () - \n\n        vm.checkCredit = checkCredit\n        vm.total = 0\n\n    checkCredit = () - \n\n        creditService.check()\n\n    init()\n\n    return\n\n  OrderController\n    .$inject = [\n      'creditService'\n    ]\n\n  angular\n    .module('app')\n    .controller('OrderController', OrderController)\n)()", 
            "title": "Defer Controller Logic to Services"
        }, 
        {
            "location": "/#keep-controllers-focused", 
            "text": "Define a controller for a view, and try not to reuse the controller for other views. Instead, move reusable logic to services and keep the controller simple and focused on its view.   Reusing controllers with several views is brittle and good end-to-end (e2e) test coverage is required to ensure stability across large applications.", 
            "title": "Keep Controllers Focused"
        }, 
        {
            "location": "/#services", 
            "text": "", 
            "title": "Services"
        }, 
        {
            "location": "/#singletons", 
            "text": "Services are singletons and return an object that contains the members of the service.   Services are instantiated with the  new  keyword, use  this  for public methods and variables. Since these are so similar to factories, use a service instead of factories for consistency.   Note:  All Angular services are singletons . This means that there is only one instance of a given service per injector.  # recommended\n# service\n(- \n  loggerService = () - \n\n    return {\n        logError: (msg) - \n        # ... #\n    }\n\n  angular\n    .module('app')\n    .service('loggerService', loggerService)\n)()", 
            "title": "Singletons"
        }, 
        {
            "location": "/#services-single-responsibility", 
            "text": "Services should have a  single responsibility , that is encapsulated by its context. Once a service begins to exceed that singular purpose, a new service should be created.", 
            "title": "Services Single Responsibility"
        }, 
        {
            "location": "/#accessible-members-up-top", 
            "text": "Expose the callable members of the service (its interface) at the top, using a technique derived from the  Revealing Module Pattern .    Placing the callable members at the top makes it easy to read and helps you instantly identify which members of the service can be called and must be unit tested (and/or mocked).    This is especially helpful when the file gets longer as it helps avoid the need to scroll to see what is exposed.    Setting functions as you go can be easy, but when those functions are more than 1 line of code they can reduce the readability and cause more scrolling. Defining the callable interface via the returned service moves the implementation details down, keeps the callable interface up top, and makes it easier to read.    NOTE : The javascript version of this style guide uses hoisted functions. CoffeeScript does not provide the ability do use function declarations (hoisted functions). So write functions in the return object.  # avoid\n(- \n  dataService = () - \n\n    someValue = ''\n\n    save = () - \n        # ... #\n\n    validate = () - \n        # ... #\n\n    return\n        save: save,\n        someValue: someValue,\n        validate: validate\n\n  angular\n    .module('app')\n    .service('dataService', dataService)\n)()  # recommended\n(- \n  dataService = () - \n\n    someValue = ''\n\n    return\n        save: () - \n        # . #\n\n        validate: () - \n        # . #\n  angular\n    .module('app')\n    .service('dataService', dataService)\n)()", 
            "title": "Accessible Members Up Top"
        }, 
        {
            "location": "/#data-services", 
            "text": "", 
            "title": "Data Services"
        }, 
        {
            "location": "/#separate-data-calls", 
            "text": "Refactor logic for making data operations and interacting with data to a service. Make data services responsible for XHR calls, local storage, stashing in memory, or any other data operations.    The controller's responsibility is for the presentation and gathering of information for the view. It should not care how it gets the data, just that it knows who to ask for it. Separating the data services moves the logic on how to get it to the data service, and lets the controller be simpler and more focused on the view.    This makes it easier to test (mock or real) the data calls when testing a controller that uses a data service.    Data service implementation may have very specific code to handle the data repository. This may include headers, how to talk to the data, or other services such as  $http . Separating the logic into a data service encapsulates this logic in a single place hiding the implementation from the outside consumers (perhaps a controller), also making it easier to change the implementation.    # recommended\n\n# dataService\n(- \n  dataService = (\n    $http,\n    logger\n  ) - \n\n    getAvengersComplete = (response)- \n          response.data.results\n\n    getAvengersFailed = (error)- \n          logger.error('XHR Failed for getAvengers.' + error.data)\n\n    return {\n      getAvengers: () - \n        return $http.get('/api/maa')\n            .then(getAvengersComplete)\n            .catch(getAvengersFailed)\n    }\n\n\n  dataService\n      .$inject = [\n        '$http',\n        'logger'\n      ]\n\n  angular\n    .module('app.core')\n    .service('dataService', dataService)\n)()  Note: The data service is called from consumers, such as a controller, hiding the implementation from the consumers, as shown below.  # recommended\n\n# controller calling the dataservice service\n(- \n  AvengersController = (\n    dataService,\n    logger\n  )- \n\n    var vm = @\n    vm.avengers = []\n\n    activate = () - \n        getAvengers().then () - \n            logger.info('Activated Avengers View')\n\n    getAvengers = () - \n        dataservice.getAvengers()\n            .then (data)- \n                vm.avengers = data\n\n  AvengersController\n    .$inject = [\n      'dataService',\n      'logger'\n    ]\n\n  angular\n    .module('app.avengers')\n    .controller('AvengersController', AvengersController)\n)()", 
            "title": "Separate Data Calls"
        }, 
        {
            "location": "/#return-a-promise-from-data-calls", 
            "text": "When calling a data service that returns a promise such as  $http , return a promise in your calling function too.   You can chain the promises together and take further action after the data call completes and resolves or rejects the promise.   # recommended\n\nactivate = () - \n\n  # Step 1\n  # Ask the getAvengers function for the avenger data and wait for the promise\n\n  getAvengers().then () - \n\n    # Step 4\n    # Perform an action on resolve of final promise\n\n    logger.info('Activated Avengers View')\n\n\ngetAvengers = () - \n\n  # Step 2\n  # Ask the data service for the data and wait for the promise\n\n  return dataservice.getAvengers()\n    .then (data)- \n\n      # Step 3\n      # set the data and resolve the promise\n\n      vm.avengers = data", 
            "title": "Return a Promise from Data Calls"
        }, 
        {
            "location": "/#manual-annotating-for-dependency-injection", 
            "text": "", 
            "title": "Manual Annotating for Dependency Injection"
        }, 
        {
            "location": "/#unsafe-from-minification", 
            "text": "Avoid using the shortcut syntax of declaring dependencies without using a minification-safe approach.   The parameters to the component (e.g. controller, service, etc) will be converted to mangled variables. For example,  common  and  dataservice  may become  a  or  b  and not be found by Angular.   # avoid - not minification-safe ###\n(- \n  Dashboard = (common, dataservice)- \n\n  angular\n    .module('app')\n    .controller('Dashboard', Dashboard)\n)()  This code may produce mangled variables when minified and thus cause runtime errors.  /* avoid - not minification-safe*/\nangular.module('app').controller('DashboardController', d);function d(a, b) { }", 
            "title": "UnSafe from Minification"
        }, 
        {
            "location": "/#manually-identify-dependencies", 
            "text": "Use  $inject  to manually identify your dependencies for Angular components.    This technique mirrors the technique used by  ng-annotate , which I recommend for automating the creation of minification safe dependencies. If  ng-annotate  detects injection has already been made, it will not duplicate it.    This safeguards your dependencies from being vulnerable to minification issues when parameters may be mangled. For example,  common  and  dataservice  may become  a  or  b  and not be found by Angular.    Avoid creating in-line dependencies as long lists can be difficult to read in the array. Also it can be confusing that the array is a series of strings while the last item is the component's function.    # avoid\n(- \n  Dashboard = ($location, $routeParams, common, dataservice)- \n\n  angular\n    .module('app')\n    .controller('Dashboard',\n        ['$location', '$routeParams', 'common', 'dataservice', Dashboard])\n)()  # recommended\n(- \n  Dashboard = (\n    $location,\n    $routeParams,\n    common,\n    dataservice\n  )- \n\n    Dashboard\n    .$inject = [\n      '$location',\n      '$routeParams',\n      'common',\n      'dataservice'\n    ]\n\n  angular\n    .module('app')\n    .controller('Dashboard', Dashboard)\n)()", 
            "title": "Manually Identify Dependencies"
        }, 
        {
            "location": "/#naming", 
            "text": "", 
            "title": "Naming"
        }, 
        {
            "location": "/#naming-guidelines", 
            "text": "Use consistent names for all components following a pattern that describes the component's feature then (optionally) its type. My recommended pattern is  feature.type.coffee . There are 2 names for most assets:   the file name ( avengers.controller.coffee )  the registered component name with Angular ( AvengersController )      Naming conventions help provide a consistent way to find content at a glance. Consistency within the project is vital. Consistency with a team is important. Consistency across a company provides tremendous efficiency.    The naming conventions should simply help you find your code faster and make it easier to understand.", 
            "title": "Naming Guidelines"
        }, 
        {
            "location": "/#feature-file-names", 
            "text": "Use consistent names for all components following a pattern that describes the component's feature then (optionally) its type. My recommended pattern is  feature.type.js .    Provides a consistent way to quickly identify components.    Provides pattern matching for any automated tasks.    // recommended\n\n// controllers\navengers.controller.coffee\navengers.controller.spec.js\n\n// services/services\nlogger.service.coffee\nlogger.service.spec.js\n\n// constants\nconstants.coffee\n\n// module definition\navengers.module.coffee\n\n// routes\navengers.routes.coffee\navengers.routes.spec.js\n\n// configuration\navengers.config.coffee\n\n// directives\navenger-profile.directive.coffee\navenger-profile.directive.spec.js", 
            "title": "Feature File Names"
        }, 
        {
            "location": "/#test-file-names", 
            "text": "Name test specifications similar to the component they test with a suffix of  spec .    Provides a consistent way to quickly identify components.    Provides pattern matching for  karma  or other test runners.    // recommended\n\navengers.controller.spec.js\nlogger.service.spec.js\navengers.routes.spec.js\navenger-profile.directive.spec.js", 
            "title": "Test File Names"
        }, 
        {
            "location": "/#controller-names", 
            "text": "Use consistent names for all controllers named after their feature. Use UpperCamelCase for controllers, as they are constructors.    Provides a consistent way to quickly identify and reference controllers.    UpperCamelCase is conventional for identifying object that can be instantiated using a constructor.    # recommended\n\n#avengers.controller.coffee\n(- \n  HeroAvengersController = ()- \n\n  angular\n    .module\n    .controller('HeroAvengersController', HeroAvengersController)\n)()", 
            "title": "Controller Names"
        }, 
        {
            "location": "/#controller-name-suffix", 
            "text": "Append the controller name with the suffix  Controller .   The  Controller  suffix is more commonly used and is more explicitly descriptive.   # recommended\n\n# avengers.controller.coffee\n(- \n  AvengersController = () - \n\n    return\n\n  angular\n    .module\n    .controller('AvengersController', AvengersController)\n)()", 
            "title": "Controller Name Suffix"
        }, 
        {
            "location": "/#service-names", 
            "text": "Use consistent names for all services named after their feature. Use camel-casing for services. Avoid prefixing services with  $ . Always suffix services with  Service .    Provides a consistent way to quickly identify and reference services.    Avoids name collisions with built-in services that use the  $  prefix.    Clear service names such as  logger  do not require a suffix.    Service names such as  avengers  are nouns and require a suffix and should be named  avengersService .    # recommended\n\n# logger.service.coffee\n(- \n  loggerService = () - \n\n  angular\n    .module\n    .service('loggerService', loggerService)\n)()\n\n# credit.service.coffee\n(- \n  creditService = () - \n\n  angular\n  .module\n  .service('creditService', creditService)\n)()\n\n# customer.service.coffee\n(- \n  customerService = () - \n\n  angular\n    .module\n    .service('customerService', customerService)\n)()", 
            "title": "Service Names"
        }, 
        {
            "location": "/#directive-component-names", 
            "text": "Use consistent names for all directives using camel-case. Use a short prefix to describe the area that the directives belong (some example are company prefix or project prefix).   Provides a consistent way to quickly identify and reference components.   # recommended\n\n# avenger-profile.directive.coffee\n(- \n  xxAvengerProfile = () - \n    return\n\n  angular\n    .module\n    .directive('xxAvengerProfile', xxAvengerProfile)\n)()\n\n# usage is  xx-avenger-profile   /xx-avenger-profile", 
            "title": "Directive Component Names"
        }, 
        {
            "location": "/#modules-names", 
            "text": "When there are multiple modules, the main module file is named  app.module.coffee  while other dependent modules are named after what they represent. For example, an admin module is named  admin.module.coffee . The respective registered module names would be  app  and  admin .    Provides consistency for multiple module apps, and for expanding to large applications.    Provides easy way to use task automation to load all module definitions first, then all other angular files (for bundling).", 
            "title": "Modules Names"
        }, 
        {
            "location": "/#configuration", 
            "text": "Separate configuration for a module into its own file named after the module. A configuration file for the main  app  module is named  app.config.coffee  (or simply  config.coffee ). A configuration for a module named  admin.module.coffee  is named  admin.config.coffee .    Separates configuration from module definition, components, and active code.    Provides an identifiable place to set configuration for a module.", 
            "title": "Configuration"
        }, 
        {
            "location": "/#routes", 
            "text": "eparate route configuration into its own file. Examples might be  app.route.coffee  for the main module and  admin.route.coffee  for the  admin  module. Even in smaller apps I prefer this separation from the rest of the configuration.", 
            "title": "Routes"
        }, 
        {
            "location": "/#application-structure-lift-principle", 
            "text": "", 
            "title": "Application Structure LIFT Principle"
        }, 
        {
            "location": "/#lift", 
            "text": "Structure your app such that you can  L ocate your code quickly,  I dentify the code at a glance, keep the  F lattest structure you can, and  T ry to stay DRY. The structure should follow these 4 basic guidelines.   Provides a consistent structure that scales well, is modular, and makes it easier to increase developer efficiency by finding code quickly. Another way to check your app structure is to ask yourself: How quickly can you open and work in all of the related files for a feature?   When I find my structure is not feeling comfortable, I go back and revisit these LIFT guidelines   L ocating our code is easy  I dentify code at a glance  F lat structure as long as we can  T ry to stay DRY (Don\u2019t Repeat Yourself) or T-DRY", 
            "title": "LIFT"
        }, 
        {
            "location": "/#locate", 
            "text": "Make locating your code intuitive, simple and fast.   I find this to be super important for a project. If the team cannot find the files they need to work on quickly, they will not be able to work as efficiently as possible, and the structure needs to change. You may not know the file name or where its related files are, so putting them in the most intuitive locations and near each other saves a ton of time. A descriptive folder structure can help with this.   /bower_components\n/client\n  /app\n    /avengers\n    /blocks\n      /exception\n      /logger\n    /core\n    /dashboard\n    /data\n    /layout\n    /widgets\n  /content\n  index.pug\n.bower.json", 
            "title": "Locate"
        }, 
        {
            "location": "/#identify", 
            "text": "When you look at a file you should instantly know what it contains and represents.   You spend less time hunting and pecking for code, and become more efficient. If this means you want longer file names, then so be it. Be descriptive with file names and keeping the contents of the file to exactly 1 component. Avoid files with multiple controllers, multiple services, or a mixture. There are deviations of the 1 per file rule when I have a set of very small features that are all related to each other, they are still easily identifiable.", 
            "title": "Identify"
        }, 
        {
            "location": "/#flat", 
            "text": "Keep a flat folder structure as long as possible. When you get to 7+ files, begin considering separation.   Nobody wants to search 7 levels of folders to find a file. Think about menus on web sites \u2026 anything deeper than 2 should take serious consideration. In a folder structure there is no hard and fast number rule, but when a folder has 7-10 files, that may be time to create subfolders. Base it on your comfort level. Use a flatter structure until there is an obvious value (to help the rest of LIFT) in creating a new folder.", 
            "title": "Flat"
        }, 
        {
            "location": "/#t-dry-try-to-stick-to-dry", 
            "text": "Be DRY, but don't go nuts and sacrifice readability.   Being DRY is important, but not crucial if it sacrifices the others in LIFT, which is why I call it T-DRY. I don\u2019t want to type session-view.html for a view because, well, it\u2019s obviously a view. If it is not obvious or by convention, then I name it.", 
            "title": "T-DRY (Try to Stick to DRY)"
        }, 
        {
            "location": "/#application-structure", 
            "text": "", 
            "title": "Application Structure"
        }, 
        {
            "location": "/#overall-guidelines", 
            "text": "Have a near term view of implementation and a long term vision. In other words, start small but keep in mind on where the app is heading down the road. All of the app's code goes in a root folder named  app . All content is 1 feature per file. Each controller, service, module, view is in its own file. All 3rd party vendor scripts are stored in another root folder and not in the  app  folder. I didn't write them and I don't want them cluttering my app ( bower_components ,  scripts ,  lib ).  Note: Find more details and reasoning behind the structure at  this original post on application structure .", 
            "title": "Overall Guidelines"
        }, 
        {
            "location": "/#layout", 
            "text": "Place components that define the overall layout of the application in a folder named  layout . These may include a shell view and controller may act as the container for the app, navigation, menus, content areas, and other regions.   Organizes all layout in a single place re-used throughout the application.", 
            "title": "Layout"
        }, 
        {
            "location": "/#folders-by-feature-structure", 
            "text": "Create folders named for the feature they represent. When a folder grows to contain more than 7 files, start to consider creating a folder for them. Your threshold may be different, so adjust as needed.    A developer can locate the code, identify what each file represents at a glance, the structure is flat as can be, and there is no repetitive nor redundant names.    The LIFT guidelines are all covered.    Helps reduce the app from becoming cluttered through organizing the content and keeping them aligned with the LIFT guidelines.    When there are a lot of files (10+) locating them is easier with a consistent folder structures and more difficult in flat structures.    /**\n* recommended\n*/\n\napp/\n    app.module.coffee\n    app.config.coffee\n    components/\n        calendar.directive.coffee\n        calendar.directive.pug\n        user-profile.directive.coffee\n        user-profile.directive.pug\n    layout/\n        shell.pug\n        shell.controller.coffee\n        topnav.pug\n        topnav.controller.coffee\n    people/\n        attendees/\n            attendees.pug\n            attendees.controller.coffee\n            attendees.service.coffee\n        speekers/\n            speaker-detail/\n                speaker-detail.pug\n                speaker-detail.controller.coffee\n                speaker-detail.service.coffee\n            speakers.pug\n            speakers.controller.coffee\n        people.routes.coffee\n    services/\n        localstorage.service.coffee\n        logger.service.coffee\n        spinner.service.coffee\n    sessions/\n        session-detial/\n            session-detail.pug\n            session-detail.controller.coffee\n            session-detail.service.coffee\n        sessions.pug\n        sessions.controller.coffee\n        sessions.routes.coffee\n        sessions.service.coffee  Note: Do not structure your app using folders-by-type. This requires moving to multiple folders when working on a feature and gets unwieldy quickly as the app grows to 5, 10 or 25+ views and controllers (and other features), which makes it more difficult than folder-by-feature to locate files.  /*\n* avoid\n* Alternative folders-by-type.\n* I recommend  folders-by-feature , instead.\n*/\n\napp/\n    app.module.coffee\n    app.config.coffee\n    app.routes.coffee\n    directives.coffee\n    controllers/\n        attendees.coffee\n        session-detail.coffee\n        sessions.coffee\n        shell.coffee\n        speakers.coffee\n        speaker-detail.coffee\n        topnav.coffee\n    directives/\n        calendar.directive.coffee\n        calendar.directive.pug\n        user-profile.directive.coffee\n        user-profile.directive.pug\n    services/\n        dataservice.coffee\n        localstorage.coffee\n        logger.coffee\n        spinner.coffee\n    views/\n        attendees.pug\n        session-detail.pug\n        sessions.pug\n        shell.pug\n        speakers.pug\n        speaker-detail.pug\n        topnav.pug", 
            "title": "Folders-by-Feature Structure"
        }, 
        {
            "location": "/#modularity", 
            "text": "", 
            "title": "Modularity"
        }, 
        {
            "location": "/#many-small-self-contained-modules", 
            "text": "Create small modules that encapsulate one responsibility.   Modular applications make it easy to plug and go as they allow the development teams to build vertical slices of the applications and roll out incrementally. This means we can plug in new features as we develop them.", 
            "title": "Many Small, Self Contained Modules"
        }, 
        {
            "location": "/#create-an-app-module", 
            "text": "Create an application root module whose role is to pull together all of the modules and features of your application. Name this for your application.   Angular encourages modularity and separation patterns. Creating an application root module whose role is to tie your other modules together provides a very straightforward way to add or remove modules from your application.", 
            "title": "Create an App Module"
        }, 
        {
            "location": "/#keep-the-app-module-thin", 
            "text": "Only put logic for pulling together the app in the application module. Leave features in their own modules.    Adding additional roles to the application root to get remote data, display views, or other logic not related to pulling the app together muddies the app module and make both sets of features harder to reuse or turn off.    The app module becomes a manifest that describes which modules help define the application.", 
            "title": "Keep the App Module Thin"
        }, 
        {
            "location": "/#feature-areas-are-modules", 
            "text": "Create modules that represent feature areas, such as layout, reusable and shared services, dashboards, and app specific features (e.g. customers, admin, sales).    Self contained modules can be added to the application with little or no friction.    Sprints or iterations can focus on feature areas and turn them on at the end of the sprint or iteration.    Separating feature areas into modules makes it easier to test the modules in isolation and reuse code.", 
            "title": "Feature Areas are Modules"
        }, 
        {
            "location": "/#reusable-blocks-are-modules", 
            "text": "Create modules that represent reusable application blocks for common services such as exception handling, logging, diagnostics, security, and local data stashing.   These types of features are needed in many applications, so by keeping them separated in their own modules they can be application generic and be reused across applications.", 
            "title": "Reusable Blocks are Modules"
        }, 
        {
            "location": "/#module-dependencies", 
            "text": "The application root module depends on the app specific feature modules and any shared or reusable modules.     The main app module contains a quickly identifiable manifest of the application's features.    Each feature area contains a manifest of what it depends on, so it can be pulled in as a dependency in other applications and still work.    Intra-App features such as shared data services become easy to locate and share from within  app.core  (choose your favorite name for this module).    Note: This is a strategy for consistency. There are many good options here. Choose one that is consistent, follows Angular's dependency rules, and is easy to maintain and scale.   My structures vary slightly between projects but they all follow these guidelines for structure and modularity. The implementation may vary depending on the features and the team. In other words, don't get hung up on an exact like-for-like structure but do justify your structure using consistency, maintainability, and efficiency in mind.  In a small app, you can also consider putting all the shared dependencies in the app module where the feature modules have no direct dependencies. This makes it easier to maintain the smaller application, but makes it harder to reuse modules outside of this application.", 
            "title": "Module Dependencies"
        }, 
        {
            "location": "/#testing", 
            "text": "Unit testing helps maintain clean code, as such I included some of my recommendations for unit testing foundations with links for more information.", 
            "title": "Testing"
        }, 
        {
            "location": "/#write-tests-with-stories", 
            "text": "Write a set of tests for every story. Start with an empty test and fill them in as you write the code for the story.   Writing the test descriptions helps clearly define what your story will do, will not do, and how you can measure success.   it('should have Avengers controller', function() {\n    // TODO\n});\n\nit('should find 1 Avenger when filtered by name', function() {\n    // TODO\n});\n\nit('should have 10 Avengers', function() {\n    // TODO (mock data?)\n});\n\nit('should return Avengers via XHR', function() {\n    // TODO ($httpBackend?)\n});\n\n// and so on", 
            "title": "Write Tests with Stories"
        }, 
        {
            "location": "/#testing-library", 
            "text": "Use  Jasmine  or  Mocha  for unit testing.    Both Jasmine and Mocha are widely used in the Angular community. Both are stable, well maintained, and provide robust testing features.  Note: When using Mocha, also consider choosing an assert library such as  Chai . I prefer Mocha.", 
            "title": "Testing Library"
        }, 
        {
            "location": "/#test-runner", 
            "text": "Use  Karma  as a test runner.    Karma is easy to configure to run once or automatically when you change your code.    Karma hooks into your Continuous Integration process easily on its own or through Grunt or Gulp.    Some IDE's are beginning to integrate with Karma, such as  WebStorm  and  Visual Studio .    Karma works well with task automation leaders such as  Grunt  (with  grunt-karma ) and  Gulp . When using Gulp, use  Karma  directly and not with a plugin as the API can be called directly.    /* recommended */\n\n// Gulp example with Karma directly\nfunction startTests(singleRun, done) {\n    var child;\n    var excludeFiles = [];\n    var fork = require('child_process').fork;\n    var Server = require('karma').Server;\n    var serverSpecs = config.serverIntegrationSpecs;\n\n    if (args.startServers) {\n        log('Starting servers');\n        var savedEnv = process.env;\n        savedEnv.NODE_ENV = 'dev';\n        savedEnv.PORT = 8888;\n        child = fork(config.nodeServer);\n    } else {\n        if (serverSpecs   serverSpecs.length) {\n            excludeFiles = serverSpecs;\n        }\n    }\n\n    var karmaOptions = {\n      configFile: __dirname + '/karma.conf.js',\n      exclude: excludeFiles,\n      singleRun: !!singleRun\n    };\n\n    let server = new Server(karmaOptions, karmaCompleted);\n    server.start();\n\n    ////////////////\n\n    function karmaCompleted(karmaResult) {\n        log('Karma completed');\n        if (child) {\n            log('shutting down the child process');\n            child.kill();\n        }\n        if (karmaResult === 1) {\n            done('karma: tests failed with code ' + karmaResult);\n        } else {\n            done();\n        }\n    }\n}", 
            "title": "Test Runner"
        }, 
        {
            "location": "/#stubbing-and-spying", 
            "text": "Use  Sinon  for stubbing and spying.    Sinon works well with both Jasmine and Mocha and extends the stubbing and spying features they offer.    Sinon makes it easier to toggle between Jasmine and Mocha, if you want to try both.    Sinon has descriptive messages when tests fail the assertions.", 
            "title": "Stubbing and Spying"
        }, 
        {
            "location": "/#headless-browser", 
            "text": "Use  PhantomJS  to run your tests on a server.   PhantomJS is a headless browser that helps run your tests without needing a \"visual\" browser. So you do not have to install Chrome, Safari, IE, or other browsers on your server.   Note: You should still test on all browsers in your environment, as appropriate for your target audience.", 
            "title": "Headless Browser"
        }, 
        {
            "location": "/#organizing-tests", 
            "text": "Place unit test files (specs) side-by-side with your client code. Place specs that cover server integration or test multiple components in a separate  tests  folder.    Unit tests have a direct correlation to a specific component and file in source code.    It is easier to keep them up to date since they are always in sight. When coding whether you do TDD or test during development or test after development, the specs are side-by-side and never out of sight nor mind, and thus more likely to be maintained which also helps maintain code coverage.    When you update source code it is easier to go update the tests at the same time.    Placing them side-by-side makes it easy to find them and easy to move them with the source code if you move the source.    Having the spec nearby makes it easier for the source code reader to learn how the component is supposed to be used and to discover its known limitations.    Separating specs so they are not in a distributed build is easy with grunt or gulp.    // recommended\n\nsrc/client/app/customers/customer-detail.controller.coffee\n                        /customer-detail.controller.spec.js\n                        /customers.controller.coffee\n                        /customers.controller.spec.js\n                        /customers.module.coffee\n                        /customers.route.coffee\n                        /customers.route.spec.js", 
            "title": "Organizing Tests"
        }, 
        {
            "location": "/#constants", 
            "text": "", 
            "title": "Constants"
        }, 
        {
            "location": "/#vendor-globals", 
            "text": "Create an Angular Constant for vendor libraries' global variables.   Provides a way to inject vendor libraries that otherwise are globals. This improves code testability by allowing you to more easily know what the dependencies of your components are (avoids leaky abstractions). It also allows you to mock these dependencies, where it makes sense.   # constants.coffee\n\n# global toastr:false, moment:false\n\nangular\n  .module('app.core')\n    .constant('toastr', toastr)\n    .constant('moment', moment)  Use constants for values that do not change and do not come from another service. When constants are used only for a module that may be reused in multiple applications, place constants in a file per module named after the module. Until this is required, keep constants in the main module in a  constants.js  file.    A value that may change, even infrequently, should be retrieved from a service so you do not have to change the source code. For example, a url for a data service could be placed in a constants but a better place would be to load it from a web service.    Constants can be injected into any angular component, including providers.    When an application is separated into modules that may be reused in other applications, each stand-alone module should be able to operate on its own including any dependent constants.    # Constants used by the entire app\nangular\n  .module('app.core')\n  .constant('moment', moment);\n\n# Constants used only by the sales module\nangular\n  .module('app.sales')\n  .constant('events', {\n    ORDER_CREATED: 'event_order_created',\n    INVENTORY_DEPLETED: 'event_inventory_depleted'\n  })  Use task automation to list module definition files  *.module.coffee  before all other application JavaScript files.    Angular needs the module definitions to be registered before they are used.    Naming modules with a specific pattern such as  *.module.coffee  makes it easy to grab them with a glob and list them first.    var clientApp = './src/client/app/';\n\n// Always grab module files first\nvar files = [\n  clientApp + '**/*.module.coffee',\n  clientApp + '**/*.coffee'\n];", 
            "title": "Vendor Globals"
        }, 
        {
            "location": "/#angular-docs", 
            "text": "For anything else, API reference, check the  Angular documentation  and follow its code style if not mentioned in this guide.", 
            "title": "Angular Docs"
        }, 
        {
            "location": "/advanced/", 
            "text": "Advanced\n\n\nthis part of guide is still working in progress\n\n\nException Handling\n\n\ndecorators\n\n\nUse a \ndecorator\n, at config time using the \n$provide\n service, on the \n$exceptionHandler\n service to perform custom actions when exceptions occur.\n\n\n\n\nProvides a consistent way to handle uncaught Angular exceptions for development-time or run-time.\n\n\n\n\nNote: Another option is to override the service instead of using a decorator. This is a fine option, but if you want to keep the default behavior and extend it a decorator is recommended.\n\n\n\n(-\n\n\nexceptionConfig = ($provide)-\n\n    $provide.decorator\n        '$exceptionHandler', ['$delegate', '$log', extendExceptionHandler]\n\n\nextendExceptionHandler = ($delegate, $log)-\n\n    return (exception, cause)-\n\n        $delegate(exception, cause)\n        errorData =\n            exception: exception,\n            cause: cause\n\n        msg = 'ERROR PREFIX' + exception.message\n        $log.error(msg, errorData)\n\n        # Log during dev with http://toastrjs.com\n        # or any other technique you prefer\n        toastr.error(msg)\n\n\nangular\n    .module('app.exception')\n    .config(['$provide', exceptionConfig])\n)()\n\n\n\n\nException Catchers\n\n\nCreate a service that exposes an interface to catch and gracefully handle exceptions.\n\n\n\n\nProvides a consistent way to catch exceptions that may be thrown in your code (e.g. during XHR calls or promise failures).\n\n\n\n\nNote: The exception catcher is good for catching and reacting to specific exceptions from calls that you know may throw one. For example, when making an XHR call to retrieve data from a remote web service and you want to catch any exceptions from that service and react uniquely.\n\n\n```javascript\n  /\n recommended \n/\n  angular\n      .module('blocks.exception')\n      .service('exception', exception);\n\n\nexception.$inject = ['logger'];\n\n\nfunction exception(logger) {\n      var service = {\n          catcher: catcher\n      };\n      return service;\n\n\n  function catcher(message) {\n      return function(reason) {\n          logger.error(message, reason);\n      };\n  }\n\n\n\n}\n  ```\n\n\nRoute Errors\n\n\nHandle and log all routing errors using \n$routeChangeError\n\n\n\n\n\n\nProvides a consistent way to handle all routing errors.\n\n\n\n\n\n\nPotentially provides a better user experience if a routing error occurs and you route them to a friendly screen with more details or recovery options.\n\n\n\n\n\n\n```javascript\n  /\n recommended \n/\n  var handlingRouteChangeError = false;\n\n\nfunction handleRoutingErrors() {\n      /*\n\n        * Route cancellation:\n        * On routing error, go to the dashboard.\n        * Provide an exit clause if it tries to do it twice.\n        \n/\n      $rootScope.$on('$routeChangeError',\n          function(event, current, previous, rejection) {\n              if (handlingRouteChangeError) { return; }\n              handlingRouteChangeError = true;\n              var destination = (current \n (current.title ||\n                  current.name || current.loadedTemplateUrl)) ||\n                  'unknown target';\n              var msg = 'Error routing to ' + destination + '. ' +\n                  (rejection.msg || '');\n\n\n          /**\n            * Optionally log using a custom service or $log.\n            * (Don't forget to inject custom service)\n            */\n          logger.warning(msg, [current]);\n\n          /**\n            * On routing error, go to another route/state.\n            */\n          $location.path('/');\n\n      }\n  );\n\n\n\n}\n  ```\n\n\nStartup Logic\n\n\nConfiguration\n\n\nInject code into \nmodule configuration\n that must be configured before running the angular app. Ideal candidates include providers and constants.\n\n\n\n\nThis makes it easier to have less places for configuration.\n\n\n\n\nangular\n    .module('app')\n    .config(configure);\n\nconfigure.$inject =\n    ['routerHelperProvider', 'exceptionHandlerProvider', 'toastr'];\n\nfunction configure (routerHelperProvider, exceptionHandlerProvider, toastr) {\n    exceptionHandlerProvider.configure(config.appErrorPrefix);\n    configureStateHelper();\n\n    toastr.options.timeOut = 4000;\n    toastr.options.positionClass = 'toast-bottom-right';\n\n    ////////////////\n\n    function configureStateHelper() {\n        routerHelperProvider.configure({\n            docTitle: 'NG-Modular: '\n        });\n    }\n}\n\n\n\n\nRun Blocks\n\n\nAny code that needs to run when an application starts should be declared in a service, exposed via a function, and injected into the \nrun block\n.\n\n\n\n\nCode directly in a run block can be difficult to test. Placing in a service makes it easier to abstract and mock.\n\n\n\n\nangular\n    .module('app')\n    .run(runBlock);\n\nrunBlock.$inject = ['authenticator', 'translator'];\n\nfunction runBlock(authenticator, translator) {\n    authenticator.initialize();\n    translator.initialize();\n}\n\n\n\n\nAnimations\n\n\nUsage\n\n\nUse subtle \nanimations with Angular\n to transition between states for views and primary visual elements. Include the \nngAnimate module\n. The 3 keys are subtle, smooth, seamless.\n\n\n\n\n\n\nSubtle animations can improve User Experience when used appropriately.\n\n\n\n\n\n\nSubtle animations can improve perceived performance as views transition.\n\n\n\n\n\n\nSub Second\n\n\nUse short durations for animations. I generally start with 300ms and adjust until appropriate.\n\n\n\n\nLong animations can have the reverse effect on User Experience and perceived performance by giving the appearance of a slow application.\n\n\n\n\nanimate.css\n\n\nUse \nanimate.css\n for conventional animations.\n\n\n\n\n\n\nThe animations that animate.css provides are fast, smooth, and easy to add to your application.\n\n\n\n\n\n\nProvides consistency in your animations.\n\n\n\n\n\n\nanimate.css is widely used and tested.\n\n\n\n\n\n\nNote: See this \ngreat post by Matias Niemel\u00e4 on Angular animations\n\n\nRouting\n\n\nClient-side routing is important for creating a navigation flow between views and composing views that are made of many smaller templates and directives.\n\n\nUse the \nAngularUI Router\n for client-side routing.\n\n\n\n\n\n\nUI Router offers all the features of the Angular router plus a few additional ones including nested routes and states.\n\n\n\n\n\n\nThe syntax is quite similar to the Angular router and is easy to migrate to UI Router.\n\n\n\n\n\n\nNote: You can use a provider such as the \nrouterHelperProvider\n shown below to help configure states across files, during the run phase.\n\n\n```javascript\n  // customers.routes.js\n  angular\n      .module('app.customers')\n      .run(appRun);\n\n\n/\n @ngInject \n/\n  function appRun(routerHelper) {\n      routerHelper.configureStates(getStates());\n  }\n\n\nfunction getStates() {\n      return [\n          {\n              state: 'customer',\n              config: {\n                  abstract: true,\n                  template: '\n',\n                  url: '/customer'\n              }\n          }\n      ];\n  }\n  ```\n\n\n```javascript\n  // routerHelperProvider.js\n  angular\n      .module('blocks.router')\n      .provider('routerHelper', routerHelperProvider);\n\n\nrouterHelperProvider.$inject = ['$locationProvider', '$stateProvider', '$urlRouterProvider'];\n  /\n @ngInject \n/\n  function routerHelperProvider($locationProvider, $stateProvider, $urlRouterProvider) {\n\n\n  this.$get = RouterHelper;\n\n  $locationProvider.html5Mode(true);\n\n  RouterHelper.$inject = ['$state'];\n  /* @ngInject */\n  function RouterHelper($state) {\n      var hasOtherwise = false;\n\n      var service = {\n          configureStates: configureStates,\n          getStates: getStates\n      };\n\n      return service;\n\n      ///////////////\n\n      function configureStates(states, otherwisePath) {\n          states.forEach(function(state) {\n              $stateProvider.state(state.state, state.config);\n          });\n          if (otherwisePath \n !hasOtherwise) {\n              hasOtherwise = true;\n              $urlRouterProvider.otherwise(otherwisePath);\n          }\n      }\n\n      function getStates() { return $state.get(); }\n  }\n\n\n\n}\n  ```\n\n\nDefine routes for views in the module where they exist. Each module should contain the routes for the views in the module.\n\n\n\n\n\n\nEach module should be able to stand on its own.\n\n\n\n\n\n\nWhen removing a module or adding a module, the app will only contain routes that point to existing views.\n\n\n\n\n\n\nThis makes it easy to enable or disable portions of an application without concern over orphaned routes.\n\n\n\n\n\n\nFilters\n\n\nAvoid using filters for scanning all properties of a complex object graph. Use filters for select properties.\n\n\n\n\nFilters can easily be abused and negatively affect performance if not used wisely, for example when a filter hits a large and deep object graph.\n\n\n\n\nAngular $ Wrapper Services\n\n\n$document and $window\n\n\nUse \n$document\n and \n$window\n instead of \ndocument\n and \nwindow\n.\n\n\n\n\nThese services are wrapped by Angular and more easily testable than using document and window in tests. This helps you avoid having to mock document and window yourself.\n\n\n\n\n$timeout and $interval\n\n\nUse \n$timeout\n and \n$interval\n instead of \nsetTimeout\n and \nsetInterval\n .\n\n\n\n\nThese services are wrapped by Angular and more easily testable and handle Angular's digest cycle thus keeping data binding in sync.\n\n\n\n\nResolving Promises\n\n\nController Activation Promises\n\n\nResolve start-up logic for a controller in an \nactivate\n function.\n\n\n\n\n\n\nPlacing start-up logic in a consistent place in the controller makes it easier to locate, more consistent to test, and helps avoid spreading out the activation logic across the controller.\n\n\n\n\n\n\nThe controller \nactivate\n makes it convenient to re-use the logic for a refresh for the controller/View, keeps the logic together, gets the user to the View faster, makes animations easy on the \nng-view\n or \nui-view\n, and feels snappier to the user.\n\n\n\n\n\n\n```coffee\n  # avoid\n  (-\n\n    Avengers = (dataservice)-\n\n          init = ()=\n\n          @avengers = []\n          @title = 'Avengers'\n\n\n      dataservice\n      .getAvengers()\n      .then (data)=\n\n          @avengers = data\n\n      init()\n      return\n\nangular\n  .module('app')\n  .controller('Avengers', Avengers)\n\n\n\n)()\n  ```\n\n\n```coffee\n  # recommended\n  (-\n\n    Avengers = (dataservice)-\n\n\n  init = ()=\n\n      @avengers = []\n      @title = 'Avengers'\n\n      activate()\n\n  ##############\n\n  activate = ()=\n\n      dataservice\n      .getAvengers()\n      .then (data)=\n\n          @avengers = data\n\n  init()\n  return\n\nangular\n  .module('app')\n  .controller('Avengers', Avengers)\n\n\n\n)()\n  ```\n\n\nHandling Exceptions with Promises\n\n\nThe \ncatch\n block of a promise must return a rejected promise to maintain the exception in the promise chain.\n\n\nAlways handle exceptions in services.\n\n\n\n\n\n\nIf the \ncatch\n block does not return a rejected promise, the caller of the promise will not know an exception occurred. The caller's \nthen\n will execute. Thus, the user may never know what happened.\n\n\n\n\n\n\nTo avoid swallowing errors and misinforming the user.\n\n\n\n\n\n\nNote: Consider putting any exception handling in a function in a shared module and service.\n\n\n/* avoid */\n\nfunction getCustomer(id) {\n    return $http.get('/api/customer/' + id)\n        .then(getCustomerComplete)\n        .catch(getCustomerFailed);\n\n    function getCustomerComplete(data, status, headers, config) {\n        return data.data;\n    }\n\n    function getCustomerFailed(e) {\n        var newMessage = 'XHR Failed for getCustomer'\n        if (e.data \n e.data.description) {\n          newMessage = newMessage + '\\n' + e.data.description;\n        }\n        e.data.description = newMessage;\n        logger.error(newMessage);\n        // ***\n        // Notice there is no return of the rejected promise\n        // ***\n    }\n}\n\n/* recommended */\nfunction getCustomer(id) {\n    return $http.get('/api/customer/' + id)\n        .then(getCustomerComplete)\n        .catch(getCustomerFailed);\n\n    function getCustomerComplete(data, status, headers, config) {\n        return data.data;\n    }\n\n    function getCustomerFailed(e) {\n        var newMessage = 'XHR Failed for getCustomer'\n        if (e.data \n e.data.description) {\n          newMessage = newMessage + '\\n' + e.data.description;\n        }\n        e.data.description = newMessage;\n        logger.error(newMessage);\n        return $q.reject(e);\n    }\n}\n\n\n\n\nDirectives\n\n\nLimit 1 Per File\n\n\nCreate one directive per file. Name the file for the directive.\n\n\n\n\n\n\nIt is easy to mash all the directives in one file, but difficult to then break those out so some are shared across apps, some across modules, some just for one module.\n\n\n\n\n\n\nOne directive per file is easy to maintain.\n\n\n\n\n\n\n\n\nNote: \"\nBest Practice\n: Directives should clean up after themselves. You can use \nelement.on('$destroy', ...)\n or \nscope.$on('$destroy', ...)\n to run a clean-up function when the directive is removed\" ... from the Angular documentation.\n\n\n\n\n# avoid\nangular\n    .module('app.widgets')\n\n    # order directive that is specific to the order module\n    .directive('orderCalendarRange', orderCalendarRange)\n\n    # sales directive that can be used anywhere across the sales app\n    .directive('salesCustomerInfo', salesCustomerInfo)\n\n    # spinner directive that can be used anywhere across apps\n    .directive('sharedSpinner', sharedSpinner)\n\n\n\n\n\n# recommended\n\n# order directive that is specific to the order module at a company named Acme\nangular\n    .module('sales.order')\n    .directive('acmeOrderCalendarRange', orderCalendarRange)\n\n# spinner directive that can be used anywhere across the sales app at a company named Acme\nangular\n    .module('sales.widgets')\n    .directive('acmeSalesCustomerInfo', salesCustomerInfo)\n\n# spinner directive that can be used anywhere across apps at a company named Acme\nangular\n    .module('shared.widgets')\n    .directive('acmeSharedSpinner', sharedSpinner)\n\n\n\n\n\nNote: There are many naming options for directives, especially since they can be used in narrow or wide scopes. Choose one that makes the directive and its file name distinct and clear. Some examples are below, but see the \nNaming\n section for more recommendations.\n\n\nManipulate DOM in a Directive\n\n\nWhen manipulating the DOM directly, use a directive. If alternative ways can be used such as using CSS to set styles or the \nanimation services\n, Angular templating, \nngShow\n or \nngHide\n, then use those instead. For example, if the directive simply hides and shows, use ngHide/ngShow.\n\n\n\n\nDOM manipulation can be difficult to test, debug, and there are often better ways (e.g. CSS, animations, templates)\n\n\n\n\nProvide a Unique Directive Prefix\n\n\nProvide a short, unique and descriptive directive prefix such as \nacmeSalesCustomerInfo\n which would be declared in HTML as \nacme-sales-customer-info\n.\n\n\n\n\nThe unique short prefix identifies the directive's context and origin. For example a prefix of \ncc-\n may indicate that the directive is part of a CodeCamper app while \nacme-\n may indicate a directive for the Acme company.\n\n\n\n\nNote: Avoid \nng-\n as these are reserved for Angular directives. Research widely used directives to avoid naming conflicts, such as \nion-\n for the \nIonic Framework\n.\n\n\nRestrict to Elements and Attributes\n\n\nWhen creating a directive that makes sense as a stand-alone element, allow restrict \nE\n (custom element) and optionally restrict \nA\n (custom attribute). Generally, if it could be its own control, \nE\n is appropriate. General guideline is allow \nEA\n but lean towards implementing as an element when it's stand-alone and as an attribute when it enhances its existing DOM element.\n\n\n\n\n\n\nIt makes sense.\n\n\n\n\n\n\nWhile we can allow the directive to be used as a class, if the directive is truly acting as an element it makes more sense as an element or at least as an attribute.\n\n\n\n\n\n\nNote: EA is the default for Angular 1.3 +\n\n\npug\n  //avoid\n  div.my-calendar-range\n\n\n```coffee\n  # avoid\n  (-\n\n      myCalendarRange = () -\n\n          link = (scope, element, attrs)-\n\n          # ... #\n\n\n      directive =\n      link: link,\n      templateUrl: '/template/is/located/here.html',\n      restrict: 'C'\n\n      return directive\n\n  angular\n      .module('app.widgets')\n      .directive('myCalendarRange', myCalendarRange)\n\n\n\n)()\n  ```\n\n\nhtml\n  //recommended\n  div\n    my-calendar-range\n\n\n```coffee\n  # recommended\n  (-\n\n\n  myCalendarRange = () -\n\n\n      link = (scope, element, attrs)-\n\n      # ... #\n\n      directive =\n          link: link,\n          templateUrl: '/template/is/located/here.html',\n          restrict: 'EA'\n\n      return directive\n\n  angular\n      .module('app.widgets')\n      .directive('myCalendarRange', myCalendarRange)\n\n\n\n)()\n  ```\n\n\nDirectives and ControllerAs\n\n\nUse \ncontroller as\n syntax with a directive to be consistent with using \ncontroller as\n with view and controller pairings.\n\n\n\n\nIt makes sense and it's not difficult.\n\n\n\n\nNote: The directive below demonstrates some of the ways you can use scope inside of link and directive controllers, using controllerAs. I in-lined the template just to keep it all in one place.\n\n\nNote: Regarding dependency injection, see \nManually Identify Dependencies\n.\n\n\nNote: Note that the directive's controller is outside the directive's closure. This style eliminates issues where the injection gets created as unreachable code after a \nreturn\n.\n\n\n\n\n\ndiv my-example max=\n77\n/div\n\n\n\n\n\nmyExample = () -\n\n  directive =\n    restrict: 'EA'\n    templateUrl: 'app/feature/example.directive.html'\n    scope: max: '='\n    link: linkFunc\n    controller: ExampleController\n    controllerAs: 'vm'\n    bindToController: true\n\n  linkFunc = (scope, el, attr, ctrl) -\n\n    console.log 'LINK: scope.min = %s *** should be undefined', scope.min\n    console.log 'LINK: scope.max = %s *** should be undefined', scope.max\n    console.log 'LINK: scope.vm.min = %s', scope.vm.min\n    console.log 'LINK: scope.vm.max = %s', scope.vm.max\n\n  return directive\n\nExampleController = ($scope) -\n\n  # Injecting $scope just for comparison\n  vm = this\n  vm.min = 3\n  console.log 'CTRL: $scope.vm.min = %s', $scope.vm.min\n  console.log 'CTRL: $scope.vm.max = %s', $scope.vm.max\n  console.log 'CTRL: vm.min = %s', vm.min\n  console.log 'CTRL: vm.max = %s', vm.max\n\nangular.module('app').directive 'myExample', myExample\nExampleController.$inject = [ '$scope' ]\n\n\n\n\ndiv hello world\ndiv\n  | max={{vm.max}}\n  input(ng-model='vm.max')\ndiv\n  | min={{vm.min}}\n  input(ng-model='vm.min')\n\n\n\n\nUse \nbindToController = true\n when using \ncontroller as\n syntax with a directive when you want to bind the outer scope to the directive's controller's scope.\n\n\n\n\nIt makes it easy to bind outer scope to the directive's controller scope.\n\n\n\n\nNote: \nbindToController\n was introduced in Angular 1.3.0.\n\n\ndiv(my-example='', max='77')\n\n\n\n\n(-\n\n  myExample = () -\n\n    directive =\n      restrict: 'EA'\n      templateUrl: 'app/feature/example.directive.html'\n      scope: max: '='\n      controller: ExampleController\n      controllerAs: 'vm'\n      bindToController: true\n    return directive\n\nangular\n  .module('app')\n  .directive('myExample', myExample)\n\n\n\n\ndiv hello world\ndiv\n  | max={{vm.max}}\n  input(ng-model='vm.max')\ndiv\n  | min={{vm.min}}\n  input(ng-model='vm.min')", 
            "title": "Advanced"
        }, 
        {
            "location": "/advanced/#advanced", 
            "text": "this part of guide is still working in progress", 
            "title": "Advanced"
        }, 
        {
            "location": "/advanced/#exception-handling", 
            "text": "", 
            "title": "Exception Handling"
        }, 
        {
            "location": "/advanced/#decorators", 
            "text": "Use a  decorator , at config time using the  $provide  service, on the  $exceptionHandler  service to perform custom actions when exceptions occur.   Provides a consistent way to handle uncaught Angular exceptions for development-time or run-time.   Note: Another option is to override the service instead of using a decorator. This is a fine option, but if you want to keep the default behavior and extend it a decorator is recommended.  \n(- \n\nexceptionConfig = ($provide)- \n    $provide.decorator\n        '$exceptionHandler', ['$delegate', '$log', extendExceptionHandler]\n\n\nextendExceptionHandler = ($delegate, $log)- \n    return (exception, cause)- \n        $delegate(exception, cause)\n        errorData =\n            exception: exception,\n            cause: cause\n\n        msg = 'ERROR PREFIX' + exception.message\n        $log.error(msg, errorData)\n\n        # Log during dev with http://toastrjs.com\n        # or any other technique you prefer\n        toastr.error(msg)\n\n\nangular\n    .module('app.exception')\n    .config(['$provide', exceptionConfig])\n)()", 
            "title": "decorators"
        }, 
        {
            "location": "/advanced/#exception-catchers", 
            "text": "Create a service that exposes an interface to catch and gracefully handle exceptions.   Provides a consistent way to catch exceptions that may be thrown in your code (e.g. during XHR calls or promise failures).   Note: The exception catcher is good for catching and reacting to specific exceptions from calls that you know may throw one. For example, when making an XHR call to retrieve data from a remote web service and you want to catch any exceptions from that service and react uniquely.  ```javascript\n  /  recommended  /\n  angular\n      .module('blocks.exception')\n      .service('exception', exception);  exception.$inject = ['logger'];  function exception(logger) {\n      var service = {\n          catcher: catcher\n      };\n      return service;    function catcher(message) {\n      return function(reason) {\n          logger.error(message, reason);\n      };\n  }  }\n  ```", 
            "title": "Exception Catchers"
        }, 
        {
            "location": "/advanced/#route-errors", 
            "text": "Handle and log all routing errors using  $routeChangeError    Provides a consistent way to handle all routing errors.    Potentially provides a better user experience if a routing error occurs and you route them to a friendly screen with more details or recovery options.    ```javascript\n  /  recommended  /\n  var handlingRouteChangeError = false;  function handleRoutingErrors() {\n      /* \n        * Route cancellation:\n        * On routing error, go to the dashboard.\n        * Provide an exit clause if it tries to do it twice.\n         /\n      $rootScope.$on('$routeChangeError',\n          function(event, current, previous, rejection) {\n              if (handlingRouteChangeError) { return; }\n              handlingRouteChangeError = true;\n              var destination = (current   (current.title ||\n                  current.name || current.loadedTemplateUrl)) ||\n                  'unknown target';\n              var msg = 'Error routing to ' + destination + '. ' +\n                  (rejection.msg || '');            /**\n            * Optionally log using a custom service or $log.\n            * (Don't forget to inject custom service)\n            */\n          logger.warning(msg, [current]);\n\n          /**\n            * On routing error, go to another route/state.\n            */\n          $location.path('/');\n\n      }\n  );  }\n  ```", 
            "title": "Route Errors"
        }, 
        {
            "location": "/advanced/#startup-logic", 
            "text": "", 
            "title": "Startup Logic"
        }, 
        {
            "location": "/advanced/#configuration", 
            "text": "Inject code into  module configuration  that must be configured before running the angular app. Ideal candidates include providers and constants.   This makes it easier to have less places for configuration.   angular\n    .module('app')\n    .config(configure);\n\nconfigure.$inject =\n    ['routerHelperProvider', 'exceptionHandlerProvider', 'toastr'];\n\nfunction configure (routerHelperProvider, exceptionHandlerProvider, toastr) {\n    exceptionHandlerProvider.configure(config.appErrorPrefix);\n    configureStateHelper();\n\n    toastr.options.timeOut = 4000;\n    toastr.options.positionClass = 'toast-bottom-right';\n\n    ////////////////\n\n    function configureStateHelper() {\n        routerHelperProvider.configure({\n            docTitle: 'NG-Modular: '\n        });\n    }\n}", 
            "title": "Configuration"
        }, 
        {
            "location": "/advanced/#run-blocks", 
            "text": "Any code that needs to run when an application starts should be declared in a service, exposed via a function, and injected into the  run block .   Code directly in a run block can be difficult to test. Placing in a service makes it easier to abstract and mock.   angular\n    .module('app')\n    .run(runBlock);\n\nrunBlock.$inject = ['authenticator', 'translator'];\n\nfunction runBlock(authenticator, translator) {\n    authenticator.initialize();\n    translator.initialize();\n}", 
            "title": "Run Blocks"
        }, 
        {
            "location": "/advanced/#animations", 
            "text": "", 
            "title": "Animations"
        }, 
        {
            "location": "/advanced/#usage", 
            "text": "Use subtle  animations with Angular  to transition between states for views and primary visual elements. Include the  ngAnimate module . The 3 keys are subtle, smooth, seamless.    Subtle animations can improve User Experience when used appropriately.    Subtle animations can improve perceived performance as views transition.", 
            "title": "Usage"
        }, 
        {
            "location": "/advanced/#sub-second", 
            "text": "Use short durations for animations. I generally start with 300ms and adjust until appropriate.   Long animations can have the reverse effect on User Experience and perceived performance by giving the appearance of a slow application.", 
            "title": "Sub Second"
        }, 
        {
            "location": "/advanced/#animatecss", 
            "text": "Use  animate.css  for conventional animations.    The animations that animate.css provides are fast, smooth, and easy to add to your application.    Provides consistency in your animations.    animate.css is widely used and tested.    Note: See this  great post by Matias Niemel\u00e4 on Angular animations", 
            "title": "animate.css"
        }, 
        {
            "location": "/advanced/#routing", 
            "text": "Client-side routing is important for creating a navigation flow between views and composing views that are made of many smaller templates and directives.  Use the  AngularUI Router  for client-side routing.    UI Router offers all the features of the Angular router plus a few additional ones including nested routes and states.    The syntax is quite similar to the Angular router and is easy to migrate to UI Router.    Note: You can use a provider such as the  routerHelperProvider  shown below to help configure states across files, during the run phase.  ```javascript\n  // customers.routes.js\n  angular\n      .module('app.customers')\n      .run(appRun);  /  @ngInject  /\n  function appRun(routerHelper) {\n      routerHelper.configureStates(getStates());\n  }  function getStates() {\n      return [\n          {\n              state: 'customer',\n              config: {\n                  abstract: true,\n                  template: ' ',\n                  url: '/customer'\n              }\n          }\n      ];\n  }\n  ```  ```javascript\n  // routerHelperProvider.js\n  angular\n      .module('blocks.router')\n      .provider('routerHelper', routerHelperProvider);  routerHelperProvider.$inject = ['$locationProvider', '$stateProvider', '$urlRouterProvider'];\n  /  @ngInject  /\n  function routerHelperProvider($locationProvider, $stateProvider, $urlRouterProvider) {    this.$get = RouterHelper;\n\n  $locationProvider.html5Mode(true);\n\n  RouterHelper.$inject = ['$state'];\n  /* @ngInject */\n  function RouterHelper($state) {\n      var hasOtherwise = false;\n\n      var service = {\n          configureStates: configureStates,\n          getStates: getStates\n      };\n\n      return service;\n\n      ///////////////\n\n      function configureStates(states, otherwisePath) {\n          states.forEach(function(state) {\n              $stateProvider.state(state.state, state.config);\n          });\n          if (otherwisePath   !hasOtherwise) {\n              hasOtherwise = true;\n              $urlRouterProvider.otherwise(otherwisePath);\n          }\n      }\n\n      function getStates() { return $state.get(); }\n  }  }\n  ```  Define routes for views in the module where they exist. Each module should contain the routes for the views in the module.    Each module should be able to stand on its own.    When removing a module or adding a module, the app will only contain routes that point to existing views.    This makes it easy to enable or disable portions of an application without concern over orphaned routes.", 
            "title": "Routing"
        }, 
        {
            "location": "/advanced/#filters", 
            "text": "Avoid using filters for scanning all properties of a complex object graph. Use filters for select properties.   Filters can easily be abused and negatively affect performance if not used wisely, for example when a filter hits a large and deep object graph.", 
            "title": "Filters"
        }, 
        {
            "location": "/advanced/#angular-wrapper-services", 
            "text": "", 
            "title": "Angular $ Wrapper Services"
        }, 
        {
            "location": "/advanced/#document-and-window", 
            "text": "Use  $document  and  $window  instead of  document  and  window .   These services are wrapped by Angular and more easily testable than using document and window in tests. This helps you avoid having to mock document and window yourself.", 
            "title": "$document and $window"
        }, 
        {
            "location": "/advanced/#timeout-and-interval", 
            "text": "Use  $timeout  and  $interval  instead of  setTimeout  and  setInterval  .   These services are wrapped by Angular and more easily testable and handle Angular's digest cycle thus keeping data binding in sync.", 
            "title": "$timeout and $interval"
        }, 
        {
            "location": "/advanced/#resolving-promises", 
            "text": "", 
            "title": "Resolving Promises"
        }, 
        {
            "location": "/advanced/#controller-activation-promises", 
            "text": "Resolve start-up logic for a controller in an  activate  function.    Placing start-up logic in a consistent place in the controller makes it easier to locate, more consistent to test, and helps avoid spreading out the activation logic across the controller.    The controller  activate  makes it convenient to re-use the logic for a refresh for the controller/View, keeps the logic together, gets the user to the View faster, makes animations easy on the  ng-view  or  ui-view , and feels snappier to the user.    ```coffee\n  # avoid\n  (- \n    Avengers = (dataservice)- \n          init = ()= \n          @avengers = []\n          @title = 'Avengers'        dataservice\n      .getAvengers()\n      .then (data)= \n          @avengers = data\n\n      init()\n      return\n\nangular\n  .module('app')\n  .controller('Avengers', Avengers)  )()\n  ```  ```coffee\n  # recommended\n  (- \n    Avengers = (dataservice)-    init = ()= \n      @avengers = []\n      @title = 'Avengers'\n\n      activate()\n\n  ##############\n\n  activate = ()= \n      dataservice\n      .getAvengers()\n      .then (data)= \n          @avengers = data\n\n  init()\n  return\n\nangular\n  .module('app')\n  .controller('Avengers', Avengers)  )()\n  ```", 
            "title": "Controller Activation Promises"
        }, 
        {
            "location": "/advanced/#handling-exceptions-with-promises", 
            "text": "The  catch  block of a promise must return a rejected promise to maintain the exception in the promise chain.  Always handle exceptions in services.    If the  catch  block does not return a rejected promise, the caller of the promise will not know an exception occurred. The caller's  then  will execute. Thus, the user may never know what happened.    To avoid swallowing errors and misinforming the user.    Note: Consider putting any exception handling in a function in a shared module and service.  /* avoid */\n\nfunction getCustomer(id) {\n    return $http.get('/api/customer/' + id)\n        .then(getCustomerComplete)\n        .catch(getCustomerFailed);\n\n    function getCustomerComplete(data, status, headers, config) {\n        return data.data;\n    }\n\n    function getCustomerFailed(e) {\n        var newMessage = 'XHR Failed for getCustomer'\n        if (e.data   e.data.description) {\n          newMessage = newMessage + '\\n' + e.data.description;\n        }\n        e.data.description = newMessage;\n        logger.error(newMessage);\n        // ***\n        // Notice there is no return of the rejected promise\n        // ***\n    }\n}\n\n/* recommended */\nfunction getCustomer(id) {\n    return $http.get('/api/customer/' + id)\n        .then(getCustomerComplete)\n        .catch(getCustomerFailed);\n\n    function getCustomerComplete(data, status, headers, config) {\n        return data.data;\n    }\n\n    function getCustomerFailed(e) {\n        var newMessage = 'XHR Failed for getCustomer'\n        if (e.data   e.data.description) {\n          newMessage = newMessage + '\\n' + e.data.description;\n        }\n        e.data.description = newMessage;\n        logger.error(newMessage);\n        return $q.reject(e);\n    }\n}", 
            "title": "Handling Exceptions with Promises"
        }, 
        {
            "location": "/advanced/#directives", 
            "text": "", 
            "title": "Directives"
        }, 
        {
            "location": "/advanced/#limit-1-per-file", 
            "text": "Create one directive per file. Name the file for the directive.    It is easy to mash all the directives in one file, but difficult to then break those out so some are shared across apps, some across modules, some just for one module.    One directive per file is easy to maintain.     Note: \" Best Practice : Directives should clean up after themselves. You can use  element.on('$destroy', ...)  or  scope.$on('$destroy', ...)  to run a clean-up function when the directive is removed\" ... from the Angular documentation.   # avoid\nangular\n    .module('app.widgets')\n\n    # order directive that is specific to the order module\n    .directive('orderCalendarRange', orderCalendarRange)\n\n    # sales directive that can be used anywhere across the sales app\n    .directive('salesCustomerInfo', salesCustomerInfo)\n\n    # spinner directive that can be used anywhere across apps\n    .directive('sharedSpinner', sharedSpinner)  # recommended\n\n# order directive that is specific to the order module at a company named Acme\nangular\n    .module('sales.order')\n    .directive('acmeOrderCalendarRange', orderCalendarRange)\n\n# spinner directive that can be used anywhere across the sales app at a company named Acme\nangular\n    .module('sales.widgets')\n    .directive('acmeSalesCustomerInfo', salesCustomerInfo)\n\n# spinner directive that can be used anywhere across apps at a company named Acme\nangular\n    .module('shared.widgets')\n    .directive('acmeSharedSpinner', sharedSpinner)  Note: There are many naming options for directives, especially since they can be used in narrow or wide scopes. Choose one that makes the directive and its file name distinct and clear. Some examples are below, but see the  Naming  section for more recommendations.", 
            "title": "Limit 1 Per File"
        }, 
        {
            "location": "/advanced/#manipulate-dom-in-a-directive", 
            "text": "When manipulating the DOM directly, use a directive. If alternative ways can be used such as using CSS to set styles or the  animation services , Angular templating,  ngShow  or  ngHide , then use those instead. For example, if the directive simply hides and shows, use ngHide/ngShow.   DOM manipulation can be difficult to test, debug, and there are often better ways (e.g. CSS, animations, templates)", 
            "title": "Manipulate DOM in a Directive"
        }, 
        {
            "location": "/advanced/#provide-a-unique-directive-prefix", 
            "text": "Provide a short, unique and descriptive directive prefix such as  acmeSalesCustomerInfo  which would be declared in HTML as  acme-sales-customer-info .   The unique short prefix identifies the directive's context and origin. For example a prefix of  cc-  may indicate that the directive is part of a CodeCamper app while  acme-  may indicate a directive for the Acme company.   Note: Avoid  ng-  as these are reserved for Angular directives. Research widely used directives to avoid naming conflicts, such as  ion-  for the  Ionic Framework .", 
            "title": "Provide a Unique Directive Prefix"
        }, 
        {
            "location": "/advanced/#restrict-to-elements-and-attributes", 
            "text": "When creating a directive that makes sense as a stand-alone element, allow restrict  E  (custom element) and optionally restrict  A  (custom attribute). Generally, if it could be its own control,  E  is appropriate. General guideline is allow  EA  but lean towards implementing as an element when it's stand-alone and as an attribute when it enhances its existing DOM element.    It makes sense.    While we can allow the directive to be used as a class, if the directive is truly acting as an element it makes more sense as an element or at least as an attribute.    Note: EA is the default for Angular 1.3 +  pug\n  //avoid\n  div.my-calendar-range  ```coffee\n  # avoid\n  (- \n      myCalendarRange = () - \n          link = (scope, element, attrs)- \n          # ... #        directive =\n      link: link,\n      templateUrl: '/template/is/located/here.html',\n      restrict: 'C'\n\n      return directive\n\n  angular\n      .module('app.widgets')\n      .directive('myCalendarRange', myCalendarRange)  )()\n  ```  html\n  //recommended\n  div\n    my-calendar-range  ```coffee\n  # recommended\n  (-    myCalendarRange = () - \n\n      link = (scope, element, attrs)- \n      # ... #\n\n      directive =\n          link: link,\n          templateUrl: '/template/is/located/here.html',\n          restrict: 'EA'\n\n      return directive\n\n  angular\n      .module('app.widgets')\n      .directive('myCalendarRange', myCalendarRange)  )()\n  ```", 
            "title": "Restrict to Elements and Attributes"
        }, 
        {
            "location": "/advanced/#directives-and-controlleras", 
            "text": "Use  controller as  syntax with a directive to be consistent with using  controller as  with view and controller pairings.   It makes sense and it's not difficult.   Note: The directive below demonstrates some of the ways you can use scope inside of link and directive controllers, using controllerAs. I in-lined the template just to keep it all in one place.  Note: Regarding dependency injection, see  Manually Identify Dependencies .  Note: Note that the directive's controller is outside the directive's closure. This style eliminates issues where the injection gets created as unreachable code after a  return .   div my-example max= 77 /div   myExample = () - \n  directive =\n    restrict: 'EA'\n    templateUrl: 'app/feature/example.directive.html'\n    scope: max: '='\n    link: linkFunc\n    controller: ExampleController\n    controllerAs: 'vm'\n    bindToController: true\n\n  linkFunc = (scope, el, attr, ctrl) - \n    console.log 'LINK: scope.min = %s *** should be undefined', scope.min\n    console.log 'LINK: scope.max = %s *** should be undefined', scope.max\n    console.log 'LINK: scope.vm.min = %s', scope.vm.min\n    console.log 'LINK: scope.vm.max = %s', scope.vm.max\n\n  return directive\n\nExampleController = ($scope) - \n  # Injecting $scope just for comparison\n  vm = this\n  vm.min = 3\n  console.log 'CTRL: $scope.vm.min = %s', $scope.vm.min\n  console.log 'CTRL: $scope.vm.max = %s', $scope.vm.max\n  console.log 'CTRL: vm.min = %s', vm.min\n  console.log 'CTRL: vm.max = %s', vm.max\n\nangular.module('app').directive 'myExample', myExample\nExampleController.$inject = [ '$scope' ]  div hello world\ndiv\n  | max={{vm.max}}\n  input(ng-model='vm.max')\ndiv\n  | min={{vm.min}}\n  input(ng-model='vm.min')  Use  bindToController = true  when using  controller as  syntax with a directive when you want to bind the outer scope to the directive's controller's scope.   It makes it easy to bind outer scope to the directive's controller scope.   Note:  bindToController  was introduced in Angular 1.3.0.  div(my-example='', max='77')  (- \n  myExample = () - \n    directive =\n      restrict: 'EA'\n      templateUrl: 'app/feature/example.directive.html'\n      scope: max: '='\n      controller: ExampleController\n      controllerAs: 'vm'\n      bindToController: true\n    return directive\n\nangular\n  .module('app')\n  .directive('myExample', myExample)  div hello world\ndiv\n  | max={{vm.max}}\n  input(ng-model='vm.max')\ndiv\n  | min={{vm.min}}\n  input(ng-model='vm.min')", 
            "title": "Directives and ControllerAs"
        }, 
        {
            "location": "/about/", 
            "text": "About\n\n\nOpinionated AngularJS CoffeeScript Style Guide designed for teams\n\n\nReferences\n\n\n\n\nAngularJS Style Guide\n by \n@john_papa\n\n\nAngularJS CoffeeScript Style Guide\n by \n@JoelCox\n\n\n\n\nContributing\n\n\nOpen an issue first to discuss potential changes/additions. If you have questions with the guide, feel free to leave them as issues in the repository. If you find a typo, create a pull request.\n\n\nLicense\n\n\nThe MIT License\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the 'Software'), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.", 
            "title": "About"
        }, 
        {
            "location": "/about/#about", 
            "text": "Opinionated AngularJS CoffeeScript Style Guide designed for teams", 
            "title": "About"
        }, 
        {
            "location": "/about/#references", 
            "text": "AngularJS Style Guide  by  @john_papa  AngularJS CoffeeScript Style Guide  by  @JoelCox", 
            "title": "References"
        }, 
        {
            "location": "/about/#contributing", 
            "text": "Open an issue first to discuss potential changes/additions. If you have questions with the guide, feel free to leave them as issues in the repository. If you find a typo, create a pull request.", 
            "title": "Contributing"
        }, 
        {
            "location": "/about/#license", 
            "text": "", 
            "title": "License"
        }, 
        {
            "location": "/about/#the-mit-license", 
            "text": "Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the 'Software'), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.  THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.", 
            "title": "The MIT License"
        }
    ]
}